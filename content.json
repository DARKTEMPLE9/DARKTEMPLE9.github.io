{"meta":{"title":"个人成长","subtitle":null,"description":null,"author":"darktemple9","url":"darktemple9.github.io"},"pages":[{"title":"categories","date":"2018-02-13T13:07:41.000Z","updated":"2018-02-13T13:20:55.000Z","comments":false,"path":"categories/index.html","permalink":"darktemple9.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-02-13T13:06:10.000Z","updated":"2018-02-13T13:20:34.000Z","comments":false,"path":"tags/index.html","permalink":"darktemple9.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"迎接新年","slug":"迎接新年","date":"2018-02-15T04:51:45.000Z","updated":"2018-02-15T05:04:29.000Z","comments":true,"path":"2018/02/15/迎接新年/","link":"","permalink":"darktemple9.github.io/2018/02/15/迎接新年/","excerpt":"","text":"今天是鸡年最后一天，大年三十，明天即狗年。愿新的一年里顺顺利利,吉祥如意！","categories":[],"tags":[{"name":"Life","slug":"Life","permalink":"darktemple9.github.io/tags/Life/"}]},{"title":"ELF文件解析","slug":"ELF文件解析","date":"2018-02-14T01:16:14.000Z","updated":"2018-02-14T01:53:25.000Z","comments":true,"path":"2018/02/14/ELF文件解析/","link":"","permalink":"darktemple9.github.io/2018/02/14/ELF文件解析/","excerpt":"","text":"最近正在看四哥的黄皮书，看里面so文件解析这一章是用java实现的，为加深理解自己实现了一遍。 写这种文件解析和以前写网络packet解析思路差不多，搞清楚文件格式然后就是代码翻译。下面是ELF文件的头文件结构。ELF文件中只有ELF Header有固定的位置。 12345678910111213141516typedef struct elf32_hdr&#123; unsigned char e_ident[EI_NIDENT]; //magic number Elf32_Half e_type; //Ojbect file type Elf32_Half e_machine; //Architecture Elf32_Word e_version; //Object file version Elf32_Addr e_entry; //entry point Elf32_Off e_phoff; //程序头内容在文件的偏移量 Elf32_off e_shoff; //段头内容在文件的偏移量 Elf32_Word e_flags; Elf32_Half e_ehsize; //elf头部大小 Elf32_Half e_phentsize; //程序头部表格的表项大小 Elf32_Half e_phnum; //程序头的个数Program header Elf32_Half e_shentsize; //节区头部表格的表项大小 Elf32_Half e_shnum; //段头的个数Section header Elf32_Half e_shstrndx; //String段在整个段列表中的索引值&#125;Elf32_Ehdr; elfhdr是字典，基本就是key：value的方式存储header的各个属性。每个属性从多少字节开始占几位都是固定的，剩下的就是学习python 文件操作函数和binascii库函数。调试的话目前基本就用print输出，高级点的还不太清楚。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def init_elf(filename): f = open(filename,\"rb\") global elfhdr magic = binascii.b2a_hex(f.read(16)) #7f 45 4c 46 -&gt; 127 E L F 判断标识 identify = magic[0:8] if identify != '7f454c46': print \"the file is not elf!\" exit(0) else: elfhdr['magic'] = magic.decode('hex') #文件offset从16字节开始，向后读取两个得到type #binascii库是二进制和ascii转化库，decode处理后是0300,小端模式要reverse， #然后再转化为hex,最后int(str,base)，以16进制转化前面的字符串 f.seek(16, 0) e_type = int(binascii.b2a_hex(f.read(2)).decode('hex')[::-1].encode('hex'),16) elfhdr['e_type'] = e_type #文件offset从18字节开始,向后读取2个得到machine f.seek(18, 0) e_machine = int(binascii.b2a_hex(f.read(2)).decode('hex')[::-1].encode('hex'),16) elfhdr['e_machine'] = e_machine f.seek(20, 0) e_version = int(binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex'),16) elfhdr['e_version'] = e_version f.seek(24, 0) e_entry = int(binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex'),16) elfhdr['e_entry'] = e_entry f.seek(28, 0) e_phoff = int(binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex'),16) elfhdr['e_phoff'] = e_phoff f.seek(32, 0) e_shoff = int(binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex'),16) elfhdr['e_shoff'] = e_shoff f.seek(36, 0) e_flags = int(binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex'),16) elfhdr['e_flags'] = e_flags f.seek(40, 0) e_ehsize = int(binascii.b2a_hex(f.read(2)).decode('hex')[::-1].encode('hex'),16) elfhdr['e_ehsize'] = e_ehsize f.seek(42, 0) e_phentsize = int(binascii.b2a_hex(f.read(2)).decode('hex')[::-1].encode('hex'),16) elfhdr['e_phentsize'] = e_phentsize f.seek(44, 0) e_phnum = int(binascii.b2a_hex(f.read(2)).decode('hex')[::-1].encode('hex'),16) elfhdr['e_phnum'] = e_phnum f.seek(46, 0) e_shentsize = int(binascii.b2a_hex(f.read(2)).decode('hex')[::-1].encode('hex'),16) elfhdr['e_shentsize'] = e_shentsize f.seek(48, 0) e_shnum= int(binascii.b2a_hex(f.read(2)).decode('hex')[::-1].encode('hex'),16) elfhdr['e_shnum'] = e_shnum f.seek(50, 0) e_shstrndx = int(binascii.b2a_hex(f.read(2)).decode('hex')[::-1].encode('hex'),16) elfhdr['e_shstrndx'] = e_shstrndx f.close() 解析函数 1234567891011121314151617181920212223242526272829303132333435363738394041def parse_elfhdr(): magic = elfhdr['magic'].encode('hex') #python 2.x print不换行需要后面加, print \"Magic: \", for i in range(0,len(magic)-2,2): print magic[i:i+2] + \" \", print #7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 #第五个字节01是判断ELF类别的,0是非法类别，1是ELF32,2是ELF64 el_class = magic[8:10] if el_class == '01': print \"Class: ELF32\" elif el_class == '02': print \"Class: ELF64\" else: print \"invalid el_class!\" exit(0) el_data = magic[10:12] if el_data == '01': print \"Data: little endian\" elif el_data == '02': print \"Data: big endian\" else: print \"invalid el_data!\" el_version = int(magic[12:14]) #int convert to str el_version = str(el_version) print \"Version: \" + el_version + \" (current)\" print \"Type: \" + str(elfhdr['e_type']) print \"Machine \" + str(elfhdr['e_machine']) print \"Version \" + str(elfhdr['e_version']) print \"入口点地址 \" + str(elfhdr['e_entry']) print \"程序头起点 \" + str(elfhdr['e_phoff']) print \"Start of section headers: \" + str(elfhdr['e_shoff']) print \"标志： \" + str(hex(elfhdr['e_flags'])) print \"本头的大小: \" + str(elfhdr['e_ehsize']) + \"字节\" print \"程序的大小: \" + str(elfhdr['e_phentsize']) + \"字节\" print \"Number of program headers: \" + str(elfhdr['e_phnum']) print \"节头大小: \" + str(elfhdr['e_shentsize']) + \"字节\" print \"节头数量: \" + str(elfhdr['e_shnum']) print \"字符串表索引节头: \" + str(elfhdr['e_shstrndx']) Program Header程序头信息： ELF文件中的程序头部是个结构数组，每个结构描述了一个段或系统准备程序执行所必需的其他信息。解析思路还是要关注ELF Header中的几个关键信息，e_phnum是程序头个数，e_phensize是程序头部表格表项大小，e_phoff是程序头在程序中的偏移量： 12345678910typedef struct elf32_phdr&#123; Elf32_Word p_type; Elf32_Off p_offset; Elf32_Addr p_vaddr; Elf32_Addr p_paddr; Elf32_Word p_filesz; Elf32_Word p_memsz; Elf32_Word p_flags; Elf32_Word p_align;&#125;Elf32_Phdr 12345678910111213141516171819202122def parse_program_headers(elf_file): elfPhdr = &#123;&#125; programs = [] pro_start = elfhdr['e_phoff'] pro_size = elfhdr['e_phentsize'] pro_num = elfhdr['e_phnum'] f = open(elf_file,'rb') for i in range(0,pro_num): pro_start = pro_start + i * pro_size #类似Section Header解析，算出每次Program Header的Offset f.seek(pro_start, 0) elfPhdr = &#123;&#125; elfPhdr['p_type'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfPhdr['p_offset'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfPhdr['p_vaddr'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfPhdr['p_paddr'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfPhdr['p_filesz'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfPhdr['p_memsz'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfPhdr['p_flags'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfPhdr['p_align'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') print elfPhdr programs.append(elfPhdr) f.close() Section Header解析实现和Program Header类似： 123456789101112typedef struct elf32_shdr&#123; Elf32_Word sh_name; Elf32_Word sh_type; Elf32_Word sh_flags; Elf32_Addr sh_addr; Elf32_Off sh_offset; Elf32_Word sh_size; Elf32_Word sh_link; Elf32_Word sh_info; Elf32_Word sh_addralign; Elf32_Word sh_entsize;&#125;Elf32_Shdr 12345678910111213141516171819202122232425def parse_section_headers(elf_file): elfShdr = &#123;&#125; sections = [] #list来保存每个Section Header信息 sec_start = elfhdr['e_shoff'] #section header在elf文件中起始地偏移量 sec_size = elfhdr['e_shentsize'] #每个Section Header的大小 sec_num = elfhdr['e_shnum'] #Section Header的个数 f = open(elf_file,'rb') for i in range(0,sec_num): sec_start = sec_start + i * sec_size #每读完一个Section Header就更新下偏移地址 f.seek(sec_start, 0) elfShdr = &#123;&#125; elfShdr['sh_name'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfShdr['sh_type'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfShdr['sh_flags'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfShdr['sh_addr'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfShdr['sh_offset'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfShdr['sh_size'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfShdr['sh_link'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfShdr['sh_info'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfShdr['sh_addralign'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') elfShdr['sh_entsize'] = binascii.b2a_hex(f.read(4)).decode('hex')[::-1].encode('hex') print elfShdr sections.append(elfShdr) f.close()","categories":[{"name":"Security","slug":"Security","permalink":"darktemple9.github.io/categories/Security/"}],"tags":[{"name":"Android Security","slug":"Android-Security","permalink":"darktemple9.github.io/tags/Android-Security/"}]},{"title":"一些hexo建站要点","slug":"一些hexo建站要点","date":"2018-02-14T00:18:18.000Z","updated":"2018-02-14T01:15:34.000Z","comments":true,"path":"2018/02/14/一些hexo建站要点/","link":"","permalink":"darktemple9.github.io/2018/02/14/一些hexo建站要点/","excerpt":"","text":"​ 今天情人节，也是大年29，趁着这段时间不忙给已经废弃的blog换个theme，简单记录下。 ​ hexo 和 github搭建blog网上很多资料，这里只记录一些问题。下面是一些常见命令： 12345678910111213mkdir my_bloghexo init //初始化hexo d //部署hexo g //生成hexo s //启动服务预览hexo clean //清空db和public文件夹 hexo new &quot;new blog&quot; //新建文章 hexo d的时候经常碰到Error Deployer not found：github的问题。问题在于没有安装相应的程序：https://github.com/hexojs/hexo/issues/1040 1npm install hexo-deployer-git --save hexo s预览没有问题，但是hexo d部署不到github上去，这主要是_config.yml中deploy没有配置好：repo可以从github中clone with ssh中获取 123deploy: type: git repo: git@github.com:xxx/xxx.github.io.git 更换theme最简单的做法就是git clone theme主题后复制到themes下，然后修改my_blog下的_config.yml中theme属性，这里我用的是indigo https://github.com/yscoder/hexo-theme-indigo/wiki 1theme: hexo-theme-indigo indigo中默认是没有开启tags和categories的，找了半天才明白需要按照上面链接的wiki手工设置，具体在issue中也有回答。 https://github.com/yscoder/hexo-theme-indigo/issues/154 搭好之后修改下my_blog/_config.yml中一些基本显示信息就OK了。。","categories":[{"name":"Technology","slug":"Technology","permalink":"darktemple9.github.io/categories/Technology/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"darktemple9.github.io/tags/Hexo/"}]},{"title":"直销银行，生存更重要","slug":"直销银行，生存更重要","date":"2017-12-10T09:32:07.000Z","updated":"2018-02-13T13:41:31.000Z","comments":true,"path":"2017/12/10/直销银行，生存更重要/","link":"","permalink":"darktemple9.github.io/2017/12/10/直销银行，生存更重要/","excerpt":"","text":"​ 最近经常看到直销银行这个词，正好前些日子看新闻说百信银行在北京开业了。关注了一些材料，接触了一些产品，对于直销银行本身有些思考。 ​ 直销银行这个概念其实是互联网金融时代的产物，基本就是不设线下实体网点，所有业务都是通过网上银行、ATM、手机银行等远程业务模式与终端客户进行业务往来的银行。目前来看，除了百信银行这种独立法人形式的直销银行外，更多的是中小型银行喜欢建立直销银行，但一般多是该行底下的一个部门。虽然各种领导给百信银行站台，背后大股东中信和百度都是非常有实力的，但本身其前景我认为还是有些挑战的。 ​ 第一就是如何生存。从一些银行官网看我感觉直销银行的定位就是“存款+理财+货币基金”，但是银行业本身的信贷业务没影子。这种产物的业务模式目前来看并没有太大的核心竞争力。纵观我看过国内区域银行的一些产品，基本就停留在用更高的投资收益来吸引客户。有文章说直销银行的服务对象是零售客户，可是直销银行有场景吗？和那些大型支付公司比它怎么获取客流呢？支付公司或者传统银行可以获取其签约商户的各种数据，有利于建立商户的信用评级，根据数据流量能更精准的提供服务，从某种意义上这是一种普惠金融。可直销银行呢，没有场景怎么积累数据呢？给小微企业提供金融服务本身就有风险，其客户画像本身不好刻画。搞金融和安全一样，我认为风险控制要永远高于其他，更不用说和一些炒作概念型的创新相比了。 ​ 再来说说同质化问题。我发现同质化问题不止安全圈的各种产品同质化严重，银行业本身也不少。就拿百信银行来说，我真的很想知道百信银行和百度金融相比有什么更特别的地方，或者更直白点和那些互联网公司成立的金融集团相比有何竞争力？刚成立几年可能集团股东、有关部门领导会给予大量支持，但是后来呢？直销银行也是企业，还是得创造利润来生存，这部分利润怎么创造呢？靠着大数据、AI智能投顾等各种过度包装的技术就能解决了？很多时候我们讲要将金融服务于实体，要践行普惠金融。这种顶层设计是绝对正确的，可是具体到经营咱们得想商业模式，到底直销银行服务于谁，怎么生存、怎么能在各种互联网金融集团的包围中存活下来是最关键的。 ​ 最后我还是想再次强调，FinTech可能本身可以提高我们的效率，节约我们的运营成本。但是初创企业最重要的还是要尽可能的盈利，尽可能得有自己的壁垒和城墙来活下去，否则万一哪天不在风口浪尖了，第一个倒下怕不是这种概念型的产物了。。。","categories":[{"name":"Compliance","slug":"Compliance","permalink":"darktemple9.github.io/categories/Compliance/"}],"tags":[{"name":"Policy","slug":"Policy","permalink":"darktemple9.github.io/tags/Policy/"}]},{"title":"Janus漏洞一些记录","slug":"Janus漏洞一些记录","date":"2017-12-10T08:19:54.000Z","updated":"2018-02-13T13:40:58.000Z","comments":true,"path":"2017/12/10/Janus漏洞一些记录/","link":"","permalink":"darktemple9.github.io/2017/12/10/Janus漏洞一些记录/","excerpt":"","text":"最近这两天经常看到关于Janus漏洞的转载，大致意思是修改App而不影响签名，特记录汇总一些细节。 参考： https://www.guardsquare.com/en/blog/new-android-vulnerability-allows-attackers-modify-apps-without-affecting-their-signatures https://www.anquanke.com/post/id/89979 https://source.android.com/security/apksigning/v2?hl=zh-cn#integrity-protected-contents 背景介绍： Google在Android 7.0后引入了v2作为APK签名方案。这种方案是一种全文件签名方案，为了向下兼容。开发者应该先用JAR签名功能对APK进行签名，然后再使用v2方案进行签名。 上图中APK签名分块就包含v2签名和签名者身份信息。 APK签名分块负责保护ZIP条目的内容、ZIP中央目录、ZIP中央目录结尾及APK签名方案v2分块中的signed data的数据完整性。 CVE-2017-13156 Janus漏洞 APK文件是一个zip文件，它可以在zip文件之前（或者是在zip文件之间）包含任意字节。JAR签名模式（v1）只会考虑zip条目，这个方案在计算或者验证应用签名时会忽略额外字节。另外，Dex文件可以包括在最后包括任意字节，例如在常规的Sections之后strings、classes、method definitions之后。总结成一句话就是一个文件可以同时是apk文件和dex文件！ 另外一个触发关键因素是ART虚拟机。理论上来说，在Android运行时载入APK后会提取DEX文件，然后执行相关代码。但在实际中，ART虚拟机可以载入并执行APK文件和DEX文件。如果找到APK文件，会根据Header中magic特征字节来判断文件类型。如果找到Dex Header，它会载入DEX文件。否则，虚拟机会将包含DEX文件的APK载入。 攻击者可以利用这种二元性，即将恶意Dex文件放到APK文件中，这样在基于JAR的签名方案下就不会影响签名。Android运行时会将这种APK看做是之前合法APK的一种升级，允许安装，然后从下图中DEX Header开始执行。 影响范围： 目前来看Janus漏洞主要针对的是Android 5.0到Android7.0的版本，利用V2 方案签名的应用不受此影响，主要是因为V2签名方案会考虑APK文件中的所有字节。 网上有人放出了POC https://github.com/V-E-O/PoC/tree/master/CVE-2017-13156 我参考使用说明跑了遍， python janus.py malware.dex original.apk out.apk 可以安装成功但是运行时会退出。 后记：目前还是不太明白实际的攻击效果，特别是对于金融级别这种上了apk完整校验保护方案的产品，有没有实质性的破坏力，我实验的2个产品都是能安装但是运行不起来，后序需要跟踪学习下。","categories":[{"name":"Security","slug":"Security","permalink":"darktemple9.github.io/categories/Security/"}],"tags":[{"name":"Android Security","slug":"Android-Security","permalink":"darktemple9.github.io/tags/Android-Security/"}]},{"title":"再谈免费加固之梆梆加固","slug":"小议梆梆加固","date":"2017-11-30T13:59:31.000Z","updated":"2018-02-13T13:38:44.000Z","comments":true,"path":"2017/11/30/小议梆梆加固/","link":"","permalink":"darktemple9.github.io/2017/11/30/小议梆梆加固/","excerpt":"","text":"前几日看了个娜迦libvdog.so的免费加固，今天简单看看梆梆加固。 先看看壳子Application：这回获取app_name不是在AndroidManifest.xml，写在Helper里面了。自定义Application中还是获取原有Application对象即realApplication然后onCreate()，都差不多。 其实如果看过企业版就知道，这个单一版还是一个Dex整体隐藏，在内存中还是可以dump的。（后来发现应该还是有函数抽取的。。） 这里还是用dexextractor来dump dex出来，但是可能是因为启动慢的原因，第一次安装后启动dump失败了，得第二次再启动才能dump到结果。另外注意下设置虚拟机Sdcard的大小，感觉Sdcard初始化100MB太小了。。 简单的说结果是两个，小点的dex是梆梆壳子的，大点的本身程序。 接下来问题来了，之前低版本baksmali用不了了，总是报错： 找了半天原因感觉可能是baksmali版本太低了，解释不了这个odex，然后赶紧下个最新的baksmali.jar包，这里是V2.2.2.https://bitbucket.org/JesusFreke/smali/downloads/ 然后想像之前用java -jar baksmali-2.2.2.jar -o output xxx.odex来执行解析，发现一直报错。 而是要像下面一样：即 java -jar baksmali-2.2.2.jar deodex -d /system/framework/ -o [out_dir] odex 具体可以参考：http://blog.csdn.net/lechengyuyuan/article/details/17146729 其实要是想直接看的话可以用Jeb 2直接打开这个ODEX文件，它能够自动把里面的inner dex解析出来。 梆梆企业版和标准版就不是一个路数了，首先看看这个AndroidManifest.xml，这保护的。。 再来说说对dex的保护。这里梆梆企业版应该是上VMP了，从apk直接得到的classes.dex确实可以转成jar来看看源码，但是一涉及到关键就是下面这个样子，是函数抽取还是啥的，反正就是容易读的放到native里去。估计so库的反调试也不少，总之就是让我等小白没招。。 后记：先后看了娜迦和梆梆的免费版加固，其实就是想说很多免费版和企业版完全不是一个路数。目前来讲学习各家免费版的脱壳还是比较有意义的，因为这类免费加固需求非常大。中小企业拿来可以应付监管，恶意软件套个壳子可以过应用市场的自动检测。那么相反，取证人员如果能够了解其中的秘密必然能更好的审查！","categories":[{"name":"Security","slug":"Security","permalink":"darktemple9.github.io/categories/Security/"}],"tags":[{"name":"Android Security","slug":"Android-Security","permalink":"darktemple9.github.io/tags/Android-Security/"}]},{"title":"dex整体加密与解密初探","slug":"dex整体加密与解密初探","date":"2017-11-27T13:56:40.000Z","updated":"2018-02-13T13:40:47.000Z","comments":true,"path":"2017/11/27/dex整体加密与解密初探/","link":"","permalink":"darktemple9.github.io/2017/11/27/dex整体加密与解密初探/","excerpt":"","text":"最近碰到个有趣的壳子，是libvdog.so的免费版，感觉和之前第一代壳子有点像，特此记录下学习点滴。 随便找个样本，apktool反编译看看AndroidManifest.xml，可以看到一个application标签。利面有个自定义的VDogApplication，还有个meta-data标签。这里meta-data标签里面的就是原Application的信息，如class_name. App启动的时候，Application中的attachBaseContext方法先调用，这里可以看看具体vdogApplication是怎么实现。这里面定义了原App的application对象，初始化自定义类加载器，获取源程序中的Application名称，通过反射生成原App的application对象。 加载原始的Application一般在onCreate()函数中，加载原始Application对象，并替换为原始Application的引用。调用baseContext并调用原始application的onCreate方法。 Dex整体加密在内存中找到dex明文就可以拿出来，目前试验过的一代壳有几种方式 梆梆 + 爱加密 + 娜迦 DexExtractor 脱壳机 drizzleDumper 360 一代，百度早期 手工断在libdvm.so dvmDexFileOpenPartial下再配上一段脚本 基本通杀一代壳，如阿里等 对于一些变态的反调，这个只能练内功。。。 后记：vdog这个其实弄出来还不算整体dex，里面onCreate()是空的，还得修复。。这个需要继续深入了 看雪文章： https://bbs.pediy.com/thread-220070.htm onCreate vs attachBaseContext：http://www.10tiao.com/html/227/201704/2650239403/1.html","categories":[{"name":"Security","slug":"Security","permalink":"darktemple9.github.io/categories/Security/"}],"tags":[{"name":"Android Security","slug":"Android-Security","permalink":"darktemple9.github.io/tags/Android-Security/"}]},{"title":"深圳之行","slug":"深圳之行","date":"2017-10-08T11:13:40.000Z","updated":"2018-02-14T01:10:52.000Z","comments":true,"path":"2017/10/08/深圳之行/","link":"","permalink":"darktemple9.github.io/2017/10/08/深圳之行/","excerpt":"","text":"​ 一周的深圳之行快要结束了，感慨颇多，特此记录。 ​ 这是我第一次来深圳，出了机场第一感觉就是热。感觉整个人就像丢进热笼里一样。坐上出租车往酒店行进，有两个直观感受。一个是车费贵，一个是城市设计凌乱。南山区高楼林立，但是不像北京一样排列非常整齐，显得非常拥挤。深圳的交通自不必说，早晚高峰堵车，但是感觉深圳的高峰期比北京晚1个小时，很可能和南山这边高新科技园里的企业上班晚有关。 ​ 说完了出行在聊聊业务。此行南下最大收获就是去了企业的生产线。平常用的电子设备想不到组装时有这么多工序，从原料、设计、装配、验收到出货等工序非常多，流程标准化显得尤为重要。合格的管理体系才能保证企业产品质量，这需要每个管理者进行摸索。此外，此行最大感受就是大力发展实体经济之重要性。诚然，大数据、云计算、人工智能等风口浪尖的技术在推动社会发展，移动支付、智能投资也大大方便了人们的生活，但请不要忘了下游的制造业。我认为技术和理念只是为了更好的革新一个产业，但真正落地还是需要实体制造。实体制造厂商所带来的经济价值和社会价值是非常扎实的。经济上来说，我认为生产具有科技含量的设备能够直接带动地方产业链的健康发展。原料采购带动下游材料生产需求，加工设备的需求能够为中游厂商提供活力，而核心技术的研发则能够使现在很多先进技术充分释放其能力，而非简单成为风投的概念产品。社会价值来讲，我认为实体制造业能够提供大量工作岗位，为每一位踏踏实实工作的人提供一份不错的生活保障。而且制造业是一个国家工业水平的直接体现。我认为我们更应该注重高新技术与实体制造业的有机结合，多关注一些有核心技术的制造业企业。 ​ 此行另外一个收获就是安防市场之大，超出想象。工厂流水线需要监控、原料存储需要监控、涉及核心的岗位、办公场所全需要监控和门禁设备。以前觉得就机场、火车站等公共场所需要这些东西，现在发现这些安防产品用途真是广泛。而且这些安防企业有个特点，它是硬件和软件结合在一起卖。软件提供一个增值服务，估计是营收重点。硬件又和制造业相关，能有效带动虚拟经济和实体经济的发展。而且目前一些龙头公司还为各行各业提供了不同的解决方案，对于国家关键基础设施提供一个保障，市场前景颇大。 ​ 最后此行就是见到了一些许久不见的老朋友。昨日到润园四季吃了椰子鸡，和几个同学一些聊聊天，非常开心。下午要回北京了，本想去看看深圳湾无奈下雨。以后有机会再说吧。 2017-9-30 上午写于南山区","categories":[{"name":"Life","slug":"Life","permalink":"darktemple9.github.io/categories/Life/"}],"tags":[{"name":"Travel","slug":"Travel","permalink":"darktemple9.github.io/tags/Travel/"}]}]}