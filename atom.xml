<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人成长</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="darktemple9.github.io/"/>
  <updated>2018-05-23T10:50:35.000Z</updated>
  <id>darktemple9.github.io/</id>
  
  <author>
    <name>darktemple9</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>dns域传送漏洞</title>
    <link href="darktemple9.github.io/2018/05/23/dns%E5%9F%9F%E4%BC%A0%E9%80%81%E6%BC%8F%E6%B4%9E/"/>
    <id>darktemple9.github.io/2018/05/23/dns域传送漏洞/</id>
    <published>2018-05-23T08:13:46.000Z</published>
    <updated>2018-05-23T10:50:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>​       大概半年前遇到过一次DNS Zone transfer漏洞，今天利用长亭科技phith0n开源的vulhub环境来搭建了下漏洞环境，简单的跑了下实验。</p><p>​       DNS域名解析服务算是很多公司的基础服务，很多公司会对DNS服务器进行主备配置。DNS服务器分为主服务器、备份服务器和缓存服务器。Zone Transfer指的是备份服务器使用主服务器的数据来更新自己的域数据库。有些环境下DNS服务器配置不当，对于匿名client发起的请求，也会返回一个域数据库的详细信息，攻击者可能会获取到被攻击域下的所有子域名、服务器IP地址等。</p><p>​       DNS Zone Transfer关键配置关注两个点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">options &#123;</span><br><span class="line">   ...</span><br><span class="line">   allow-transfer &#123;any; &#125;;<span class="comment">//通过IP或Key限制可域传送的服务器</span></span><br><span class="line">   allow-query &#123;any;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p>​     阿里云ECS运行docker，将环境跑起来</p><p>​     docker-compose up -d</p><p>​     设置安全组策略：vulhub使用bind9搭建的dns服务器，环境运行后将会监听TCP和UDP的53端口。阿里云默认安全组的入口方向53端口是关闭的，这里需要配置下开放端口，否则后面dig发请求的时候无响应。</p><p>Linux下用dig命令发送dns请求来测试是否由DNS Zone Transfer漏洞</p><p>dig @your-ip www.vulhub.org 这里ip是阿里云ECS的公网IP</p>  <center><br><br><img src="https://ws3.sinaimg.cn/large/006tKfTcgy1frldnwkc1fj31320gcdji.jpg" width="80%" height="80%" align="center"><br><br></center><p>发送axfr类型的dns请求：dig @your-ip -t axfr vulhub.org</p><center><br><br><img src="https://ws2.sinaimg.cn/large/006tKfTcly1frlgabi9opj314m0c0tcf.jpg" width="80%" height="80%" align="center"><br><br></center><p>可以获取vulhub.org的所有子域名记录。</p><p>利用nmap script脚本也可以自动扫描获取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script dns-zone-transfer.nse --script-args "dns-zone-transfer.domain=vulhub.org" -Pn -p 53 your-ip</span><br></pre></td></tr></table></figure><center><br><br><img src="https://ws1.sinaimg.cn/large/006tKfTcly1frlgabr6lzj30vo0gm42l.jpg" width="80%" height="80%" align="center"><br><br></center><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p> <a href="https://github.com/vulhub/vulhub/tree/master/dns/dns-zone-transfer" target="_blank" rel="noopener">https://github.com/vulhub/vulhub/tree/master/dns/dns-zone-transfer</a></p><p> <a href="http://vulhub.org/#/docs/" target="_blank" rel="noopener">http://vulhub.org/#/docs/</a></p><p> <a href="http://sunu11.com/2017/03/16/8/" target="_blank" rel="noopener">http://sunu11.com/2017/03/16/8/</a></p><p> <a href="http://drops.xmd5.com/static/drops/papers-64.html" target="_blank" rel="noopener">http://drops.xmd5.com/static/drops/papers-64.html</a></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>赞赏了24块钱支持下这个项目，phith0n这种分享精神我特别感激。phith0n的小密圈也是干活满满，安全娱乐圈里面的一股清流啊</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;​       大概半年前遇到过一次DNS Zone transfer漏洞，今天利用长亭科技phith0n开源的vulhub环境来搭建了下漏
      
    
    </summary>
    
      <category term="Security" scheme="darktemple9.github.io/categories/Security/"/>
    
    
      <category term="Network Security" scheme="darktemple9.github.io/tags/Network-Security/"/>
    
  </entry>
  
  <entry>
    <title>迎接新年</title>
    <link href="darktemple9.github.io/2018/02/15/%E8%BF%8E%E6%8E%A5%E6%96%B0%E5%B9%B4/"/>
    <id>darktemple9.github.io/2018/02/15/迎接新年/</id>
    <published>2018-02-15T04:51:45.000Z</published>
    <updated>2018-02-15T05:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是鸡年最后一天，大年三十，明天即狗年。愿新的一年里顺顺利利,吉祥如意！</p><center><br><br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1foh1ovnsmxj31kw23v7wj.jpg" width="80%" height="80%"><br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是鸡年最后一天，大年三十，明天即狗年。愿新的一年里顺顺利利,吉祥如意！&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1foh1ovnsmxj31kw23v7wj.jpg&quot; wi
      
    
    </summary>
    
    
      <category term="Life" scheme="darktemple9.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>ELF文件解析</title>
    <link href="darktemple9.github.io/2018/02/14/ELF%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
    <id>darktemple9.github.io/2018/02/14/ELF文件解析/</id>
    <published>2018-02-14T01:16:14.000Z</published>
    <updated>2018-02-14T01:53:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近正在看四哥的黄皮书，看里面so文件解析这一章是用java实现的，为加深理解自己实现了一遍。</p><p>写这种文件解析和以前写网络packet解析思路差不多，搞清楚文件格式然后就是代码翻译。下面是ELF文件的头文件结构。ELF文件中只有ELF Header有固定的位置。</p><center><br><br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fofq5joue6j314g0b2goc.jpg" width="80%" height="80%" align="center"><br><br></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_hdr</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT]; <span class="comment">//magic number</span></span><br><span class="line">Elf32_Half e_type;                <span class="comment">//Ojbect file type</span></span><br><span class="line">Elf32_Half e_machine;             <span class="comment">//Architecture</span></span><br><span class="line">Elf32_Word e_version;             <span class="comment">//Object file version </span></span><br><span class="line">Elf32_Addr e_entry;               <span class="comment">//entry point</span></span><br><span class="line">Elf32_Off  e_phoff;              <span class="comment">//程序头内容在文件的偏移量</span></span><br><span class="line">Elf32_off  e_shoff;              <span class="comment">//段头内容在文件的偏移量</span></span><br><span class="line">Elf32_Word e_flags;</span><br><span class="line">Elf32_Half e_ehsize;             <span class="comment">//elf头部大小</span></span><br><span class="line">Elf32_Half e_phentsize;          <span class="comment">//程序头部表格的表项大小</span></span><br><span class="line">Elf32_Half e_phnum;             <span class="comment">//程序头的个数Program header</span></span><br><span class="line">Elf32_Half e_shentsize;         <span class="comment">//节区头部表格的表项大小</span></span><br><span class="line">Elf32_Half e_shnum;            <span class="comment">//段头的个数Section header</span></span><br><span class="line">Elf32_Half e_shstrndx;         <span class="comment">//String段在整个段列表中的索引值</span></span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p>elfhdr是字典，基本就是key：value的方式存储header的各个属性。每个属性从多少字节开始占几位都是固定的，剩下的就是学习python 文件操作函数和binascii库函数。调试的话目前基本就用print输出，高级点的还不太清楚。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_elf</span><span class="params">(filename)</span>:</span></span><br><span class="line">f = open(filename,<span class="string">"rb"</span>)</span><br><span class="line"><span class="keyword">global</span> elfhdr</span><br><span class="line">magic = binascii.b2a_hex(f.read(<span class="number">16</span>))</span><br><span class="line"><span class="comment">#7f 45 4c 46 -&gt; 127 E L F 判断标识</span></span><br><span class="line">identify = magic[<span class="number">0</span>:<span class="number">8</span>]</span><br><span class="line"><span class="keyword">if</span> identify != <span class="string">'7f454c46'</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"the file is not elf!"</span></span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elfhdr[<span class="string">'magic'</span>] = magic.decode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="comment">#文件offset从16字节开始，向后读取两个得到type</span></span><br><span class="line"><span class="comment">#binascii库是二进制和ascii转化库，decode处理后是0300,小端模式要reverse，</span></span><br><span class="line"><span class="comment">#然后再转化为hex,最后int(str,base)，以16进制转化前面的字符串</span></span><br><span class="line">f.seek(<span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line">e_type = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>) </span><br><span class="line">        elfhdr[<span class="string">'e_type'</span>] = e_type</span><br><span class="line">        <span class="comment">#文件offset从18字节开始,向后读取2个得到machine</span></span><br><span class="line">        f.seek(<span class="number">18</span>, <span class="number">0</span>)</span><br><span class="line">        e_machine = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_machine'</span>] = e_machine</span><br><span class="line">        f.seek(<span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line">        e_version = int(binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_version'</span>] = e_version</span><br><span class="line">        f.seek(<span class="number">24</span>, <span class="number">0</span>)</span><br><span class="line">        e_entry = int(binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_entry'</span>] = e_entry</span><br><span class="line">        f.seek(<span class="number">28</span>, <span class="number">0</span>)</span><br><span class="line">        e_phoff = int(binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_phoff'</span>] = e_phoff</span><br><span class="line">        f.seek(<span class="number">32</span>, <span class="number">0</span>)</span><br><span class="line">        e_shoff = int(binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_shoff'</span>] = e_shoff</span><br><span class="line">        f.seek(<span class="number">36</span>, <span class="number">0</span>)</span><br><span class="line">        e_flags = int(binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_flags'</span>] = e_flags</span><br><span class="line">        f.seek(<span class="number">40</span>, <span class="number">0</span>)</span><br><span class="line">        e_ehsize = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_ehsize'</span>] = e_ehsize</span><br><span class="line">        f.seek(<span class="number">42</span>, <span class="number">0</span>)</span><br><span class="line">        e_phentsize = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_phentsize'</span>] = e_phentsize</span><br><span class="line">        f.seek(<span class="number">44</span>, <span class="number">0</span>)</span><br><span class="line">        e_phnum = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_phnum'</span>] = e_phnum</span><br><span class="line">        f.seek(<span class="number">46</span>, <span class="number">0</span>)</span><br><span class="line">        e_shentsize = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_shentsize'</span>] = e_shentsize</span><br><span class="line">        f.seek(<span class="number">48</span>, <span class="number">0</span>)</span><br><span class="line">        e_shnum= int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_shnum'</span>] = e_shnum</span><br><span class="line">        f.seek(<span class="number">50</span>, <span class="number">0</span>)</span><br><span class="line">        e_shstrndx = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_shstrndx'</span>] = e_shstrndx </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>解析函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_elfhdr</span><span class="params">()</span>:</span></span><br><span class="line">    magic = elfhdr[<span class="string">'magic'</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">    <span class="comment">#python 2.x print不换行需要后面加, </span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Magic:  "</span>,</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(magic)<span class="number">-2</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">print</span> magic[i:i+<span class="number">2</span>] + <span class="string">" "</span>,</span><br><span class="line">    <span class="keyword">print</span></span><br><span class="line">    <span class="comment">#7f  45  4c  46  01  01  01  00  00  00  00  00  00  00  00 </span></span><br><span class="line">    <span class="comment">#第五个字节01是判断ELF类别的,0是非法类别，1是ELF32,2是ELF64</span></span><br><span class="line">    el_class = magic[<span class="number">8</span>:<span class="number">10</span>]</span><br><span class="line">    <span class="keyword">if</span> el_class == <span class="string">'01'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Class: ELF32"</span></span><br><span class="line">    <span class="keyword">elif</span> el_class == <span class="string">'02'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Class: ELF64"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"invalid el_class!"</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">    el_data = magic[<span class="number">10</span>:<span class="number">12</span>]</span><br><span class="line">    <span class="keyword">if</span> el_data == <span class="string">'01'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Data: little endian"</span></span><br><span class="line">    <span class="keyword">elif</span> el_data == <span class="string">'02'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Data: big endian"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"invalid el_data!"</span></span><br><span class="line">    el_version = int(magic[<span class="number">12</span>:<span class="number">14</span>])</span><br><span class="line">    <span class="comment">#int convert to str</span></span><br><span class="line">    el_version = str(el_version)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Version: "</span> + el_version + <span class="string">" (current)"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Type: "</span> + str(elfhdr[<span class="string">'e_type'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Machine "</span> + str(elfhdr[<span class="string">'e_machine'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Version "</span> + str(elfhdr[<span class="string">'e_version'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"入口点地址 "</span> + str(elfhdr[<span class="string">'e_entry'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"程序头起点 "</span> + str(elfhdr[<span class="string">'e_phoff'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Start of section headers: "</span> + str(elfhdr[<span class="string">'e_shoff'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"标志： "</span> + str(hex(elfhdr[<span class="string">'e_flags'</span>]))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"本头的大小: "</span> + str(elfhdr[<span class="string">'e_ehsize'</span>]) + <span class="string">"字节"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"程序的大小: "</span> + str(elfhdr[<span class="string">'e_phentsize'</span>]) + <span class="string">"字节"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Number of program headers: "</span> + str(elfhdr[<span class="string">'e_phnum'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"节头大小: "</span> + str(elfhdr[<span class="string">'e_shentsize'</span>]) + <span class="string">"字节"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"节头数量: "</span> + str(elfhdr[<span class="string">'e_shnum'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"字符串表索引节头: "</span> + str(elfhdr[<span class="string">'e_shstrndx'</span>])</span><br></pre></td></tr></table></figure><p>Program Header程序头信息：</p><p>ELF文件中的程序头部是个结构数组，每个结构描述了一个段或系统准备程序执行所必需的其他信息。解析思路还是要关注ELF Header中的几个关键信息，e_phnum是程序头个数，e_phensize是程序头部表格表项大小，e_phoff是程序头在程序中的偏移量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_phdr</span>&#123;</span></span><br><span class="line">    Elf32_Word p_type; </span><br><span class="line">    Elf32_Off  p_offset;</span><br><span class="line">    Elf32_Addr p_vaddr;</span><br><span class="line">    Elf32_Addr p_paddr;  </span><br><span class="line">    Elf32_Word p_filesz;</span><br><span class="line">    Elf32_Word p_memsz;</span><br><span class="line">    Elf32_Word p_flags;</span><br><span class="line">    Elf32_Word p_align;</span><br><span class="line">&#125;Elf32_Phdr</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_program_headers</span><span class="params">(elf_file)</span>:</span></span><br><span class="line">    elfPhdr = &#123;&#125;</span><br><span class="line">    programs = []</span><br><span class="line">    pro_start = elfhdr[<span class="string">'e_phoff'</span>]</span><br><span class="line">    pro_size = elfhdr[<span class="string">'e_phentsize'</span>]</span><br><span class="line">    pro_num = elfhdr[<span class="string">'e_phnum'</span>]</span><br><span class="line">    f = open(elf_file,<span class="string">'rb'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,pro_num):</span><br><span class="line">        pro_start = pro_start + i * pro_size <span class="comment">#类似Section Header解析，算出每次Program Header的Offset</span></span><br><span class="line">        f.seek(pro_start, <span class="number">0</span>)</span><br><span class="line">        elfPhdr = &#123;&#125;</span><br><span class="line">        elfPhdr[<span class="string">'p_type'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_offset'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_vaddr'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_paddr'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_filesz'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_memsz'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_flags'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_align'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        <span class="keyword">print</span> elfPhdr</span><br><span class="line">        programs.append(elfPhdr)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>Section Header解析实现和Program Header类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_shdr</span>&#123;</span></span><br><span class="line">    Elf32_Word sh_name; </span><br><span class="line">    Elf32_Word sh_type;</span><br><span class="line">    Elf32_Word sh_flags;</span><br><span class="line">    Elf32_Addr sh_addr;</span><br><span class="line">    Elf32_Off  sh_offset;</span><br><span class="line">    Elf32_Word sh_size;</span><br><span class="line">    Elf32_Word sh_link;</span><br><span class="line">    Elf32_Word sh_info;</span><br><span class="line">    Elf32_Word sh_addralign;</span><br><span class="line">    Elf32_Word sh_entsize;</span><br><span class="line">&#125;Elf32_Shdr</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_section_headers</span><span class="params">(elf_file)</span>:</span></span><br><span class="line">    elfShdr = &#123;&#125;</span><br><span class="line">    sections = []   <span class="comment">#list来保存每个Section Header信息</span></span><br><span class="line">    sec_start = elfhdr[<span class="string">'e_shoff'</span>]    <span class="comment">#section header在elf文件中起始地偏移量</span></span><br><span class="line">    sec_size = elfhdr[<span class="string">'e_shentsize'</span>] <span class="comment">#每个Section Header的大小</span></span><br><span class="line">    sec_num = elfhdr[<span class="string">'e_shnum'</span>] <span class="comment">#Section Header的个数</span></span><br><span class="line">    f = open(elf_file,<span class="string">'rb'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,sec_num):</span><br><span class="line">        sec_start = sec_start + i * sec_size <span class="comment">#每读完一个Section Header就更新下偏移地址</span></span><br><span class="line">        f.seek(sec_start, <span class="number">0</span>)</span><br><span class="line">        elfShdr = &#123;&#125;</span><br><span class="line">        elfShdr[<span class="string">'sh_name'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_type'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_flags'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_addr'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_offset'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_size'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_link'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_info'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_addralign'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_entsize'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        <span class="keyword">print</span> elfShdr</span><br><span class="line">        sections.append(elfShdr)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近正在看四哥的黄皮书，看里面so文件解析这一章是用java实现的，为加深理解自己实现了一遍。&lt;/p&gt;
&lt;p&gt;写这种文件解析和以前写网络packet解析思路差不多，搞清楚文件格式然后就是代码翻译。下面是ELF文件的头文件结构。ELF文件中只有ELF Header有固定的位置
      
    
    </summary>
    
      <category term="Security" scheme="darktemple9.github.io/categories/Security/"/>
    
    
      <category term="Android Security" scheme="darktemple9.github.io/tags/Android-Security/"/>
    
  </entry>
  
  <entry>
    <title>一些hexo建站要点</title>
    <link href="darktemple9.github.io/2018/02/14/%E4%B8%80%E4%BA%9Bhexo%E5%BB%BA%E7%AB%99%E8%A6%81%E7%82%B9/"/>
    <id>darktemple9.github.io/2018/02/14/一些hexo建站要点/</id>
    <published>2018-02-14T00:18:18.000Z</published>
    <updated>2018-02-14T01:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>​        今天情人节，也是大年29，趁着这段时间不忙给已经废弃的blog换个theme，简单记录下。</p><p>​        hexo 和 github搭建blog网上很多资料，这里只记录一些问题。下面是一些常见命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mkdir my_blog</span><br><span class="line"></span><br><span class="line">hexo init //初始化</span><br><span class="line"></span><br><span class="line">hexo d   //部署</span><br><span class="line"></span><br><span class="line">hexo g  //生成</span><br><span class="line"></span><br><span class="line">hexo s //启动服务预览</span><br><span class="line"></span><br><span class="line">hexo clean //清空db和public文件夹</span><br><span class="line"></span><br><span class="line">hexo new &quot;new blog&quot; //新建文章</span><br></pre></td></tr></table></figure><p>hexo d的时候经常碰到Error Deployer not found：github的问题。问题在于没有安装相应的程序：<a href="https://github.com/hexojs/hexo/issues/1040" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues/1040</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>hexo s预览没有问题，但是hexo d部署不到github上去，这主要是_config.yml中deploy没有配置好：repo可以从github中clone with ssh中获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:xxx/xxx.github.io.git</span><br></pre></td></tr></table></figure><p>更换theme最简单的做法就是git clone theme主题后复制到themes下，然后修改my_blog下的_config.yml中theme属性，这里我用的是indigo</p><p><a href="https://github.com/yscoder/hexo-theme-indigo/wiki" target="_blank" rel="noopener">https://github.com/yscoder/hexo-theme-indigo/wiki</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: hexo-theme-indigo</span><br></pre></td></tr></table></figure><p>indigo中默认是没有开启tags和categories的，找了半天才明白需要按照上面链接的wiki手工设置，具体在issue中也有回答。</p><p><a href="https://github.com/yscoder/hexo-theme-indigo/issues/154" target="_blank" rel="noopener">https://github.com/yscoder/hexo-theme-indigo/issues/154</a></p><p>搭好之后修改下my_blog/_config.yml中一些基本显示信息就OK了。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        今天情人节，也是大年29，趁着这段时间不忙给已经废弃的blog换个theme，简单记录下。&lt;/p&gt;
&lt;p&gt;​        hexo 和 github搭建blog网上很多资料，这里只记录一些问题。下面是一些常见命令：&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="Technology" scheme="darktemple9.github.io/categories/Technology/"/>
    
    
      <category term="Hexo" scheme="darktemple9.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>直销银行，生存更重要</title>
    <link href="darktemple9.github.io/2017/12/10/%E7%9B%B4%E9%94%80%E9%93%B6%E8%A1%8C%EF%BC%8C%E7%94%9F%E5%AD%98%E6%9B%B4%E9%87%8D%E8%A6%81/"/>
    <id>darktemple9.github.io/2017/12/10/直销银行，生存更重要/</id>
    <published>2017-12-10T09:32:07.000Z</published>
    <updated>2018-02-13T13:41:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>​        最近经常看到直销银行这个词，正好前些日子看新闻说百信银行在北京开业了。关注了一些材料，接触了一些产品，对于直销银行本身有些思考。</p><p>​        直销银行这个概念其实是互联网金融时代的产物，基本就是不设线下实体网点，所有业务都是通过网上银行、ATM、手机银行等远程业务模式与终端客户进行业务往来的银行。目前来看，除了百信银行这种独立法人形式的直销银行外，更多的是中小型银行喜欢建立直销银行，但一般多是该行底下的一个部门。虽然各种领导给百信银行站台，背后大股东中信和百度都是非常有实力的，但本身其前景我认为还是有些挑战的。</p><p>​        第一就是如何生存。从一些银行官网看我感觉直销银行的定位就是“存款+理财+货币基金”，但是银行业本身的信贷业务没影子。这种产物的业务模式目前来看并没有太大的核心竞争力。纵观我看过国内区域银行的一些产品，基本就停留在用更高的投资收益来吸引客户。有文章说直销银行的服务对象是零售客户，可是直销银行有场景吗？和那些大型支付公司比它怎么获取客流呢？支付公司或者传统银行可以获取其签约商户的各种数据，有利于建立商户的信用评级，根据数据流量能更精准的提供服务，从某种意义上这是一种普惠金融。可直销银行呢，没有场景怎么积累数据呢？给小微企业提供金融服务本身就有风险，其客户画像本身不好刻画。搞金融和安全一样，我认为风险控制要永远高于其他，更不用说和一些炒作概念型的创新相比了。</p><p>​        再来说说同质化问题。我发现同质化问题不止安全圈的各种产品同质化严重，银行业本身也不少。就拿百信银行来说，我真的很想知道百信银行和百度金融相比有什么更特别的地方，或者更直白点和那些互联网公司成立的金融集团相比有何竞争力？刚成立几年可能集团股东、有关部门领导会给予大量支持，但是后来呢？直销银行也是企业，还是得创造利润来生存，这部分利润怎么创造呢？靠着大数据、AI智能投顾等各种过度包装的技术就能解决了？很多时候我们讲要将金融服务于实体，要践行普惠金融。这种顶层设计是绝对正确的，可是具体到经营咱们得想商业模式，到底直销银行服务于谁，怎么生存、怎么能在各种互联网金融集团的包围中存活下来是最关键的。</p><p>​       最后我还是想再次强调，FinTech可能本身可以提高我们的效率，节约我们的运营成本。但是初创企业最重要的还是要尽可能的盈利，尽可能得有自己的壁垒和城墙来活下去，否则万一哪天不在风口浪尖了，第一个倒下怕不是这种概念型的产物了。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        最近经常看到直销银行这个词，正好前些日子看新闻说百信银行在北京开业了。关注了一些材料，接触了一些产品，对于直销银行本身有些思考。&lt;/p&gt;
&lt;p&gt;​        直销银行这个概念其实是互联网金融时代的产物，基本就是不设线下实体网点，所有业务都是通过网上银行
      
    
    </summary>
    
      <category term="Compliance" scheme="darktemple9.github.io/categories/Compliance/"/>
    
    
      <category term="Policy" scheme="darktemple9.github.io/tags/Policy/"/>
    
  </entry>
  
  <entry>
    <title>Janus漏洞一些记录</title>
    <link href="darktemple9.github.io/2017/12/10/Janus%E6%BC%8F%E6%B4%9E%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
    <id>darktemple9.github.io/2017/12/10/Janus漏洞一些记录/</id>
    <published>2017-12-10T08:19:54.000Z</published>
    <updated>2018-02-13T13:40:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近这两天经常看到关于Janus漏洞的转载，大致意思是修改App而不影响签名，特记录汇总一些细节。</p><p>参考：</p><p><a href="https://www.guardsquare.com/en/blog/new-android-vulnerability-allows-attackers-modify-apps-without-affecting-their-signatures" target="_blank" rel="noopener">https://www.guardsquare.com/en/blog/new-android-vulnerability-allows-attackers-modify-apps-without-affecting-their-signatures</a> </p><p><a href="https://www.anquanke.com/post/id/89979" target="_blank" rel="noopener">https://www.anquanke.com/post/id/89979</a></p><p><a href="https://source.android.com/security/apksigning/v2?hl=zh-cn#integrity-protected-contents" target="_blank" rel="noopener">https://source.android.com/security/apksigning/v2?hl=zh-cn#integrity-protected-contents</a></p><p>背景介绍：</p><p>Google在Android 7.0后引入了v2作为APK签名方案。这种方案是一种全文件签名方案，为了向下兼容。开发者应该先用JAR签名功能对APK进行签名，然后再使用v2方案进行签名。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws2.sinaimg.cn/large/006tKfTcly1fmbr1gdqnoj316m08k75r.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上图中APK签名分块就包含v2签名和签名者身份信息。</p><p>APK签名分块负责保护ZIP条目的内容、ZIP中央目录、ZIP中央目录结尾及APK签名方案v2分块中的signed data的数据完整性。</p><p>CVE-2017-13156 Janus漏洞<img src="" alt=""></p><p>APK文件是一个zip文件，它可以在zip文件之前（或者是在zip文件之间）包含任意字节。JAR签名模式（v1）只会考虑zip条目，这个方案在计算或者验证应用签名时会忽略额外字节。另外，Dex文件可以包括在最后包括任意字节，例如在常规的Sections之后strings、classes、method definitions之后。总结成一句话就是一个文件可以同时是apk文件和dex文件！</p><p>另外一个触发关键因素是ART虚拟机。理论上来说，在Android运行时载入APK后会提取DEX文件，然后执行相关代码。但在实际中，ART虚拟机可以载入并执行APK文件和DEX文件。如果找到APK文件，会根据Header中magic特征字节来判断文件类型。如果找到Dex Header，它会载入DEX文件。否则，虚拟机会将包含DEX文件的APK载入。</p><p>攻击者可以利用这种二元性，即将恶意Dex文件放到APK文件中，这样在基于JAR的签名方案下就不会影响签名。Android运行时会将这种APK看做是之前合法APK的一种升级，允许安装，然后从下图中DEX Header开始执行。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws4.sinaimg.cn/large/006tKfTcly1fmbr1fiivoj30wk0q0ta1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>影响范围：</p><p>目前来看Janus漏洞主要针对的是Android 5.0到Android7.0的版本，利用V2 方案签名的应用不受此影响，主要是因为V2签名方案会考虑APK文件中的所有字节。</p><p>网上有人放出了POC <a href="https://github.com/V-E-O/PoC/tree/master/CVE-2017-13156" target="_blank" rel="noopener">https://github.com/V-E-O/PoC/tree/master/CVE-2017-13156</a></p><p>我参考使用说明跑了遍，</p><p>python janus.py malware.dex original.apk out.apk</p><p>可以安装成功但是运行时会退出。</p><p>后记：目前还是不太明白实际的攻击效果，特别是对于金融级别这种上了apk完整校验保护方案的产品，有没有实质性的破坏力，我实验的2个产品都是能安装但是运行不起来，后序需要跟踪学习下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近这两天经常看到关于Janus漏洞的转载，大致意思是修改App而不影响签名，特记录汇总一些细节。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.guardsquare.com/en/blog/new-android-vulnerabilit
      
    
    </summary>
    
      <category term="Security" scheme="darktemple9.github.io/categories/Security/"/>
    
    
      <category term="Android Security" scheme="darktemple9.github.io/tags/Android-Security/"/>
    
  </entry>
  
  <entry>
    <title>再谈免费加固之梆梆加固</title>
    <link href="darktemple9.github.io/2017/11/30/%E5%B0%8F%E8%AE%AE%E6%A2%86%E6%A2%86%E5%8A%A0%E5%9B%BA/"/>
    <id>darktemple9.github.io/2017/11/30/小议梆梆加固/</id>
    <published>2017-11-30T13:59:31.000Z</published>
    <updated>2018-02-13T13:38:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几日看了个娜迦libvdog.so的免费加固，今天简单看看梆梆加固。</p><p>先看看壳子Application：这回获取app_name不是在AndroidManifest.xml，写在Helper里面了。自定义Application中还是获取原有Application对象即realApplication然后onCreate()，都差不多。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws2.sinaimg.cn/large/006tKfTcly1fm0h1za44ij31jk13uthw.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws3.sinaimg.cn/large/006tKfTcly1fm0h1ww0spj30wq0gkacr.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其实如果看过企业版就知道，这个单一版还是一个Dex整体隐藏，在内存中还是可以dump的。（后来发现应该还是有函数抽取的。。）</p><p>这里还是用dexextractor来dump dex出来，但是可能是因为启动慢的原因，第一次安装后启动dump失败了，得第二次再启动才能dump到结果。另外注意下设置虚拟机Sdcard的大小，感觉Sdcard初始化100MB太小了。。</p><p>简单的说结果是两个，小点的dex是梆梆壳子的，大点的本身程序。</p><p>接下来问题来了，之前低版本baksmali用不了了，总是报错：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws4.sinaimg.cn/large/006tKfTcly1fm0h20rtqej30vw09yjuy.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>找了半天原因感觉可能是baksmali版本太低了，解释不了这个odex，然后赶紧下个最新的baksmali.jar包，这里是V2.2.2.<a href="https://bitbucket.org/JesusFreke/smali/downloads/" target="_blank" rel="noopener">https://bitbucket.org/JesusFreke/smali/downloads/</a></p><p>然后想像之前用java -jar baksmali-2.2.2.jar -o output xxx.odex来执行解析，发现一直报错。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws2.sinaimg.cn/large/006tKfTcly1fm0h20dxqrj30xu0g80zq.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>而是要像下面一样：即 java -jar baksmali-2.2.2.jar deodex -d /system/framework/ -o [out_dir] odex</p><p>具体可以参考：<a href="http://blog.csdn.net/lechengyuyuan/article/details/17146729" target="_blank" rel="noopener">http://blog.csdn.net/lechengyuyuan/article/details/17146729</a></p><p>其实要是想直接看的话可以用Jeb 2直接打开这个ODEX文件，它能够自动把里面的inner dex解析出来。</p><p>梆梆企业版和标准版就不是一个路数了，首先看看这个AndroidManifest.xml，这保护的。。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws2.sinaimg.cn/large/006tKfTcly1fm0h1y5t9xj313i0t0qmv.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>再来说说对dex的保护。这里梆梆企业版应该是上VMP了，从apk直接得到的classes.dex确实可以转成jar来看看源码，但是一涉及到关键就是下面这个样子，是函数抽取还是啥的，反正就是容易读的放到native里去。估计so库的反调试也不少，总之就是让我等小白没招。。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws3.sinaimg.cn/large/006tKfTcly1fm0h218dxrj30ta0kujtx.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>后记：先后看了娜迦和梆梆的免费版加固，其实就是想说很多免费版和企业版完全不是一个路数。目前来讲学习各家免费版的脱壳还是比较有意义的，因为这类免费加固需求非常大。中小企业拿来可以应付监管，恶意软件套个壳子可以过应用市场的自动检测。那么相反，取证人员如果能够了解其中的秘密必然能更好的审查！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几日看了个娜迦libvdog.so的免费加固，今天简单看看梆梆加固。&lt;/p&gt;
&lt;p&gt;先看看壳子Application：这回获取app_name不是在AndroidManifest.xml，写在Helper里面了。自定义Application中还是获取原有Applicati
      
    
    </summary>
    
      <category term="Security" scheme="darktemple9.github.io/categories/Security/"/>
    
    
      <category term="Android Security" scheme="darktemple9.github.io/tags/Android-Security/"/>
    
  </entry>
  
  <entry>
    <title>dex整体加密与解密初探</title>
    <link href="darktemple9.github.io/2017/11/27/dex%E6%95%B4%E4%BD%93%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E5%88%9D%E6%8E%A2/"/>
    <id>darktemple9.github.io/2017/11/27/dex整体加密与解密初探/</id>
    <published>2017-11-27T13:56:40.000Z</published>
    <updated>2018-02-13T13:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到个有趣的壳子，是libvdog.so的免费版，感觉和之前第一代壳子有点像，特此记录下学习点滴。</p><p>随便找个样本，apktool反编译看看AndroidManifest.xml，可以看到一个application标签。利面有个自定义的VDogApplication，还有个meta-data标签。这里meta-data标签里面的就是原Application的信息，如class_name.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006tKfTcly1flwzz8gzc5j319e09oae9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>App启动的时候，Application中的attachBaseContext方法先调用，这里可以看看具体vdogApplication是怎么实现。这里面定义了原App的application对象，初始化自定义类加载器，获取源程序中的Application名称，通过反射生成原App的application对象。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws2.sinaimg.cn/large/006tKfTcly1flwzz9mixcj31iu0rewqk.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>加载原始的Application一般在onCreate()函数中，加载原始Application对象，并替换为原始Application的引用。调用baseContext并调用原始application的onCreate方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006tKfTcly1flx0v14463j30xo072dhf.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Dex整体加密在内存中找到dex明文就可以拿出来，目前试验过的一代壳有几种方式</p><ul><li>梆梆 + 爱加密 + 娜迦</li><li><ul><li>DexExtractor 脱壳机</li></ul></li><li>drizzleDumper</li><li><ul><li>360 一代，百度早期</li></ul></li><li>手工断在libdvm.so dvmDexFileOpenPartial下再配上一段脚本</li><li><ul><li>基本通杀一代壳，如阿里等</li><li>对于一些变态的反调，这个只能练内功。。。</li></ul></li></ul><p>后记：vdog这个其实弄出来还不算整体dex，里面onCreate()是空的，还得修复。。这个需要继续深入了</p><p>看雪文章：                                       <a href="https://bbs.pediy.com/thread-220070.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-220070.htm</a></p><p>onCreate vs attachBaseContext：<a href="http://www.10tiao.com/html/227/201704/2650239403/1.html" target="_blank" rel="noopener">http://www.10tiao.com/html/227/201704/2650239403/1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近碰到个有趣的壳子，是libvdog.so的免费版，感觉和之前第一代壳子有点像，特此记录下学习点滴。&lt;/p&gt;
&lt;p&gt;随便找个样本，apktool反编译看看AndroidManifest.xml，可以看到一个application标签。利面有个自定义的VDogApplica
      
    
    </summary>
    
      <category term="Security" scheme="darktemple9.github.io/categories/Security/"/>
    
    
      <category term="Android Security" scheme="darktemple9.github.io/tags/Android-Security/"/>
    
  </entry>
  
  <entry>
    <title>深圳之行</title>
    <link href="darktemple9.github.io/2017/10/08/%E6%B7%B1%E5%9C%B3%E4%B9%8B%E8%A1%8C/"/>
    <id>darktemple9.github.io/2017/10/08/深圳之行/</id>
    <published>2017-10-08T11:13:40.000Z</published>
    <updated>2018-02-14T01:10:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>​        一周的深圳之行快要结束了，感慨颇多，特此记录。</p><p>​        这是我第一次来深圳，出了机场第一感觉就是热。感觉整个人就像丢进热笼里一样。坐上出租车往酒店行进，有两个直观感受。一个是车费贵，一个是城市设计凌乱。南山区高楼林立，但是不像北京一样排列非常整齐，显得非常拥挤。深圳的交通自不必说，早晚高峰堵车，但是感觉深圳的高峰期比北京晚1个小时，很可能和南山这边高新科技园里的企业上班晚有关。</p><p>​        说完了出行在聊聊业务。此行南下最大收获就是去了企业的生产线。平常用的电子设备想不到组装时有这么多工序，从原料、设计、装配、验收到出货等工序非常多，流程标准化显得尤为重要。合格的管理体系才能保证企业产品质量，这需要每个管理者进行摸索。此外，此行最大感受就是大力发展实体经济之重要性。诚然，大数据、云计算、人工智能等风口浪尖的技术在推动社会发展，移动支付、智能投资也大大方便了人们的生活，但请不要忘了下游的制造业。我认为技术和理念只是为了更好的革新一个产业，但真正落地还是需要实体制造。实体制造厂商所带来的经济价值和社会价值是非常扎实的。经济上来说，我认为生产具有科技含量的设备能够直接带动地方产业链的<br>健康发展。原料采购带动下游材料生产需求，加工设备的需求能够为中游厂商提供活力，而核心技术的研发则能够使现在很多先进技术充分释放其能力，而非简单成为风投的概念产品。社会价值来讲，我认为实体制造业能够提供大量工作岗位，为每一位踏踏实实工作的人提供一份不错的生活保障。而且制造业是一个国家工业水平的直接体现。我认为我们更应该注重高新技术与实体制造业的有机结合，多关注一些有核心技术的制造业企业。</p><p>​        此行另外一个收获就是安防市场之大，超出想象。工厂流水线需要监控、原料存储需要监控、涉及核心的岗位、办公场所全需要监控和门禁设备。以前觉得就机场、火车站等公共场所需要这些东西，现在发现这些安防产品用途真是广泛。而且这些安防企业有个特点，它是硬件和软件结合在一起卖。软件提供一个增值服务，估计是营收重点。硬件又和制造业相关，能有效带动虚拟经济和实体经济的发展。而且目前一些龙头公司还为各行各业提供了不同的解决方案，对于国家关键基础设施提供一个保障，市场前景颇大。</p><p>​        最后此行就是见到了一些许久不见的老朋友。昨日到润园四季吃了椰子鸡，和几个同学一些聊聊天，非常开心。下午要回北京了，本想去看看深圳湾无奈下雨。以后有机会再说吧。</p><p>2017-9-30 上午写于南山区 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        一周的深圳之行快要结束了，感慨颇多，特此记录。&lt;/p&gt;
&lt;p&gt;​        这是我第一次来深圳，出了机场第一感觉就是热。感觉整个人就像丢进热笼里一样。坐上出租车往酒店行进，有两个直观感受。一个是车费贵，一个是城市设计凌乱。南山区高楼林立，但是不像北京一
      
    
    </summary>
    
      <category term="Life" scheme="darktemple9.github.io/categories/Life/"/>
    
    
      <category term="Travel" scheme="darktemple9.github.io/tags/Travel/"/>
    
  </entry>
  
</feed>
