<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人成长</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="darktemple9.github.io/"/>
  <updated>2018-02-15T05:04:29.000Z</updated>
  <id>darktemple9.github.io/</id>
  
  <author>
    <name>darktemple9</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>迎接新年</title>
    <link href="darktemple9.github.io/2018/02/15/%E8%BF%8E%E6%8E%A5%E6%96%B0%E5%B9%B4/"/>
    <id>darktemple9.github.io/2018/02/15/迎接新年/</id>
    <published>2018-02-15T04:51:45.000Z</published>
    <updated>2018-02-15T05:04:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天是鸡年最后一天，大年三十，明天即狗年。愿新的一年里顺顺利利,吉祥如意！</p><center><br><br><img src="https://ws2.sinaimg.cn/large/006tNc79ly1foh1ovnsmxj31kw23v7wj.jpg" width="80%" height="80%"><br><br></center>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是鸡年最后一天，大年三十，明天即狗年。愿新的一年里顺顺利利,吉祥如意！&lt;/p&gt;
&lt;center&gt;&lt;br&gt;&lt;br&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNc79ly1foh1ovnsmxj31kw23v7wj.jpg&quot; wi
      
    
    </summary>
    
    
      <category term="Life" scheme="darktemple9.github.io/tags/Life/"/>
    
  </entry>
  
  <entry>
    <title>ELF文件解析</title>
    <link href="darktemple9.github.io/2018/02/14/ELF%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
    <id>darktemple9.github.io/2018/02/14/ELF文件解析/</id>
    <published>2018-02-14T01:16:14.000Z</published>
    <updated>2018-02-14T01:53:25.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近正在看四哥的黄皮书，看里面so文件解析这一章是用java实现的，为加深理解自己实现了一遍。</p><p>写这种文件解析和以前写网络packet解析思路差不多，搞清楚文件格式然后就是代码翻译。下面是ELF文件的头文件结构。ELF文件中只有ELF Header有固定的位置。</p><center><br><br><img src="https://ws1.sinaimg.cn/large/006tNc79ly1fofq5joue6j314g0b2goc.jpg" width="80%" height="80%" align="center"><br><br></center><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_hdr</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[EI_NIDENT]; <span class="comment">//magic number</span></span><br><span class="line">Elf32_Half e_type;                <span class="comment">//Ojbect file type</span></span><br><span class="line">Elf32_Half e_machine;             <span class="comment">//Architecture</span></span><br><span class="line">Elf32_Word e_version;             <span class="comment">//Object file version </span></span><br><span class="line">Elf32_Addr e_entry;               <span class="comment">//entry point</span></span><br><span class="line">Elf32_Off  e_phoff;              <span class="comment">//程序头内容在文件的偏移量</span></span><br><span class="line">Elf32_off  e_shoff;              <span class="comment">//段头内容在文件的偏移量</span></span><br><span class="line">Elf32_Word e_flags;</span><br><span class="line">Elf32_Half e_ehsize;             <span class="comment">//elf头部大小</span></span><br><span class="line">Elf32_Half e_phentsize;          <span class="comment">//程序头部表格的表项大小</span></span><br><span class="line">Elf32_Half e_phnum;             <span class="comment">//程序头的个数Program header</span></span><br><span class="line">Elf32_Half e_shentsize;         <span class="comment">//节区头部表格的表项大小</span></span><br><span class="line">Elf32_Half e_shnum;            <span class="comment">//段头的个数Section header</span></span><br><span class="line">Elf32_Half e_shstrndx;         <span class="comment">//String段在整个段列表中的索引值</span></span><br><span class="line">&#125;Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p>elfhdr是字典，基本就是key：value的方式存储header的各个属性。每个属性从多少字节开始占几位都是固定的，剩下的就是学习python 文件操作函数和binascii库函数。调试的话目前基本就用print输出，高级点的还不太清楚。。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init_elf</span><span class="params">(filename)</span>:</span></span><br><span class="line">f = open(filename,<span class="string">"rb"</span>)</span><br><span class="line"><span class="keyword">global</span> elfhdr</span><br><span class="line">magic = binascii.b2a_hex(f.read(<span class="number">16</span>))</span><br><span class="line"><span class="comment">#7f 45 4c 46 -&gt; 127 E L F 判断标识</span></span><br><span class="line">identify = magic[<span class="number">0</span>:<span class="number">8</span>]</span><br><span class="line"><span class="keyword">if</span> identify != <span class="string">'7f454c46'</span>:</span><br><span class="line"><span class="keyword">print</span> <span class="string">"the file is not elf!"</span></span><br><span class="line">exit(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">elfhdr[<span class="string">'magic'</span>] = magic.decode(<span class="string">'hex'</span>)</span><br><span class="line"><span class="comment">#文件offset从16字节开始，向后读取两个得到type</span></span><br><span class="line"><span class="comment">#binascii库是二进制和ascii转化库，decode处理后是0300,小端模式要reverse，</span></span><br><span class="line"><span class="comment">#然后再转化为hex,最后int(str,base)，以16进制转化前面的字符串</span></span><br><span class="line">f.seek(<span class="number">16</span>, <span class="number">0</span>)</span><br><span class="line">e_type = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>) </span><br><span class="line">        elfhdr[<span class="string">'e_type'</span>] = e_type</span><br><span class="line">        <span class="comment">#文件offset从18字节开始,向后读取2个得到machine</span></span><br><span class="line">        f.seek(<span class="number">18</span>, <span class="number">0</span>)</span><br><span class="line">        e_machine = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_machine'</span>] = e_machine</span><br><span class="line">        f.seek(<span class="number">20</span>, <span class="number">0</span>)</span><br><span class="line">        e_version = int(binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_version'</span>] = e_version</span><br><span class="line">        f.seek(<span class="number">24</span>, <span class="number">0</span>)</span><br><span class="line">        e_entry = int(binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_entry'</span>] = e_entry</span><br><span class="line">        f.seek(<span class="number">28</span>, <span class="number">0</span>)</span><br><span class="line">        e_phoff = int(binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_phoff'</span>] = e_phoff</span><br><span class="line">        f.seek(<span class="number">32</span>, <span class="number">0</span>)</span><br><span class="line">        e_shoff = int(binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_shoff'</span>] = e_shoff</span><br><span class="line">        f.seek(<span class="number">36</span>, <span class="number">0</span>)</span><br><span class="line">        e_flags = int(binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_flags'</span>] = e_flags</span><br><span class="line">        f.seek(<span class="number">40</span>, <span class="number">0</span>)</span><br><span class="line">        e_ehsize = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_ehsize'</span>] = e_ehsize</span><br><span class="line">        f.seek(<span class="number">42</span>, <span class="number">0</span>)</span><br><span class="line">        e_phentsize = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_phentsize'</span>] = e_phentsize</span><br><span class="line">        f.seek(<span class="number">44</span>, <span class="number">0</span>)</span><br><span class="line">        e_phnum = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_phnum'</span>] = e_phnum</span><br><span class="line">        f.seek(<span class="number">46</span>, <span class="number">0</span>)</span><br><span class="line">        e_shentsize = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_shentsize'</span>] = e_shentsize</span><br><span class="line">        f.seek(<span class="number">48</span>, <span class="number">0</span>)</span><br><span class="line">        e_shnum= int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_shnum'</span>] = e_shnum</span><br><span class="line">        f.seek(<span class="number">50</span>, <span class="number">0</span>)</span><br><span class="line">        e_shstrndx = int(binascii.b2a_hex(f.read(<span class="number">2</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>),<span class="number">16</span>)</span><br><span class="line">        elfhdr[<span class="string">'e_shstrndx'</span>] = e_shstrndx </span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>解析函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_elfhdr</span><span class="params">()</span>:</span></span><br><span class="line">    magic = elfhdr[<span class="string">'magic'</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">    <span class="comment">#python 2.x print不换行需要后面加, </span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Magic:  "</span>,</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,len(magic)<span class="number">-2</span>,<span class="number">2</span>):</span><br><span class="line">    <span class="keyword">print</span> magic[i:i+<span class="number">2</span>] + <span class="string">" "</span>,</span><br><span class="line">    <span class="keyword">print</span></span><br><span class="line">    <span class="comment">#7f  45  4c  46  01  01  01  00  00  00  00  00  00  00  00 </span></span><br><span class="line">    <span class="comment">#第五个字节01是判断ELF类别的,0是非法类别，1是ELF32,2是ELF64</span></span><br><span class="line">    el_class = magic[<span class="number">8</span>:<span class="number">10</span>]</span><br><span class="line">    <span class="keyword">if</span> el_class == <span class="string">'01'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Class: ELF32"</span></span><br><span class="line">    <span class="keyword">elif</span> el_class == <span class="string">'02'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Class: ELF64"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"invalid el_class!"</span></span><br><span class="line">    exit(<span class="number">0</span>)</span><br><span class="line">    el_data = magic[<span class="number">10</span>:<span class="number">12</span>]</span><br><span class="line">    <span class="keyword">if</span> el_data == <span class="string">'01'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Data: little endian"</span></span><br><span class="line">    <span class="keyword">elif</span> el_data == <span class="string">'02'</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Data: big endian"</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"invalid el_data!"</span></span><br><span class="line">    el_version = int(magic[<span class="number">12</span>:<span class="number">14</span>])</span><br><span class="line">    <span class="comment">#int convert to str</span></span><br><span class="line">    el_version = str(el_version)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Version: "</span> + el_version + <span class="string">" (current)"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Type: "</span> + str(elfhdr[<span class="string">'e_type'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Machine "</span> + str(elfhdr[<span class="string">'e_machine'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Version "</span> + str(elfhdr[<span class="string">'e_version'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"入口点地址 "</span> + str(elfhdr[<span class="string">'e_entry'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"程序头起点 "</span> + str(elfhdr[<span class="string">'e_phoff'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Start of section headers: "</span> + str(elfhdr[<span class="string">'e_shoff'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"标志： "</span> + str(hex(elfhdr[<span class="string">'e_flags'</span>]))</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"本头的大小: "</span> + str(elfhdr[<span class="string">'e_ehsize'</span>]) + <span class="string">"字节"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"程序的大小: "</span> + str(elfhdr[<span class="string">'e_phentsize'</span>]) + <span class="string">"字节"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"Number of program headers: "</span> + str(elfhdr[<span class="string">'e_phnum'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"节头大小: "</span> + str(elfhdr[<span class="string">'e_shentsize'</span>]) + <span class="string">"字节"</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">"节头数量: "</span> + str(elfhdr[<span class="string">'e_shnum'</span>])</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"字符串表索引节头: "</span> + str(elfhdr[<span class="string">'e_shstrndx'</span>])</span><br></pre></td></tr></table></figure><p>Program Header程序头信息：</p><p>ELF文件中的程序头部是个结构数组，每个结构描述了一个段或系统准备程序执行所必需的其他信息。解析思路还是要关注ELF Header中的几个关键信息，e_phnum是程序头个数，e_phensize是程序头部表格表项大小，e_phoff是程序头在程序中的偏移量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_phdr</span>&#123;</span></span><br><span class="line">    Elf32_Word p_type; </span><br><span class="line">    Elf32_Off  p_offset;</span><br><span class="line">    Elf32_Addr p_vaddr;</span><br><span class="line">    Elf32_Addr p_paddr;  </span><br><span class="line">    Elf32_Word p_filesz;</span><br><span class="line">    Elf32_Word p_memsz;</span><br><span class="line">    Elf32_Word p_flags;</span><br><span class="line">    Elf32_Word p_align;</span><br><span class="line">&#125;Elf32_Phdr</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_program_headers</span><span class="params">(elf_file)</span>:</span></span><br><span class="line">    elfPhdr = &#123;&#125;</span><br><span class="line">    programs = []</span><br><span class="line">    pro_start = elfhdr[<span class="string">'e_phoff'</span>]</span><br><span class="line">    pro_size = elfhdr[<span class="string">'e_phentsize'</span>]</span><br><span class="line">    pro_num = elfhdr[<span class="string">'e_phnum'</span>]</span><br><span class="line">    f = open(elf_file,<span class="string">'rb'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,pro_num):</span><br><span class="line">        pro_start = pro_start + i * pro_size <span class="comment">#类似Section Header解析，算出每次Program Header的Offset</span></span><br><span class="line">        f.seek(pro_start, <span class="number">0</span>)</span><br><span class="line">        elfPhdr = &#123;&#125;</span><br><span class="line">        elfPhdr[<span class="string">'p_type'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_offset'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_vaddr'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_paddr'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_filesz'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_memsz'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_flags'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfPhdr[<span class="string">'p_align'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        <span class="keyword">print</span> elfPhdr</span><br><span class="line">        programs.append(elfPhdr)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>Section Header解析实现和Program Header类似：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">elf32_shdr</span>&#123;</span></span><br><span class="line">    Elf32_Word sh_name; </span><br><span class="line">    Elf32_Word sh_type;</span><br><span class="line">    Elf32_Word sh_flags;</span><br><span class="line">    Elf32_Addr sh_addr;</span><br><span class="line">    Elf32_Off  sh_offset;</span><br><span class="line">    Elf32_Word sh_size;</span><br><span class="line">    Elf32_Word sh_link;</span><br><span class="line">    Elf32_Word sh_info;</span><br><span class="line">    Elf32_Word sh_addralign;</span><br><span class="line">    Elf32_Word sh_entsize;</span><br><span class="line">&#125;Elf32_Shdr</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_section_headers</span><span class="params">(elf_file)</span>:</span></span><br><span class="line">    elfShdr = &#123;&#125;</span><br><span class="line">    sections = []   <span class="comment">#list来保存每个Section Header信息</span></span><br><span class="line">    sec_start = elfhdr[<span class="string">'e_shoff'</span>]    <span class="comment">#section header在elf文件中起始地偏移量</span></span><br><span class="line">    sec_size = elfhdr[<span class="string">'e_shentsize'</span>] <span class="comment">#每个Section Header的大小</span></span><br><span class="line">    sec_num = elfhdr[<span class="string">'e_shnum'</span>] <span class="comment">#Section Header的个数</span></span><br><span class="line">    f = open(elf_file,<span class="string">'rb'</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,sec_num):</span><br><span class="line">        sec_start = sec_start + i * sec_size <span class="comment">#每读完一个Section Header就更新下偏移地址</span></span><br><span class="line">        f.seek(sec_start, <span class="number">0</span>)</span><br><span class="line">        elfShdr = &#123;&#125;</span><br><span class="line">        elfShdr[<span class="string">'sh_name'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_type'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_flags'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_addr'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_offset'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_size'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_link'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_info'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_addralign'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        elfShdr[<span class="string">'sh_entsize'</span>] = binascii.b2a_hex(f.read(<span class="number">4</span>)).decode(<span class="string">'hex'</span>)[::<span class="number">-1</span>].encode(<span class="string">'hex'</span>)</span><br><span class="line">        <span class="keyword">print</span> elfShdr</span><br><span class="line">        sections.append(elfShdr)</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近正在看四哥的黄皮书，看里面so文件解析这一章是用java实现的，为加深理解自己实现了一遍。&lt;/p&gt;
&lt;p&gt;写这种文件解析和以前写网络packet解析思路差不多，搞清楚文件格式然后就是代码翻译。下面是ELF文件的头文件结构。ELF文件中只有ELF Header有固定的位置
      
    
    </summary>
    
      <category term="Security" scheme="darktemple9.github.io/categories/Security/"/>
    
    
      <category term="Android Security" scheme="darktemple9.github.io/tags/Android-Security/"/>
    
  </entry>
  
  <entry>
    <title>一些hexo建站要点</title>
    <link href="darktemple9.github.io/2018/02/14/%E4%B8%80%E4%BA%9Bhexo%E5%BB%BA%E7%AB%99%E8%A6%81%E7%82%B9/"/>
    <id>darktemple9.github.io/2018/02/14/一些hexo建站要点/</id>
    <published>2018-02-14T00:18:18.000Z</published>
    <updated>2018-02-14T01:15:34.000Z</updated>
    
    <content type="html"><![CDATA[<p>​        今天情人节，也是大年29，趁着这段时间不忙给已经废弃的blog换个theme，简单记录下。</p><p>​        hexo 和 github搭建blog网上很多资料，这里只记录一些问题。下面是一些常见命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mkdir my_blog</span><br><span class="line"></span><br><span class="line">hexo init //初始化</span><br><span class="line"></span><br><span class="line">hexo d   //部署</span><br><span class="line"></span><br><span class="line">hexo g  //生成</span><br><span class="line"></span><br><span class="line">hexo s //启动服务预览</span><br><span class="line"></span><br><span class="line">hexo clean //清空db和public文件夹</span><br><span class="line"></span><br><span class="line">hexo new &quot;new blog&quot; //新建文章</span><br></pre></td></tr></table></figure><p>hexo d的时候经常碰到Error Deployer not found：github的问题。问题在于没有安装相应的程序：<a href="https://github.com/hexojs/hexo/issues/1040" target="_blank" rel="noopener">https://github.com/hexojs/hexo/issues/1040</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>hexo s预览没有问题，但是hexo d部署不到github上去，这主要是_config.yml中deploy没有配置好：repo可以从github中clone with ssh中获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:xxx/xxx.github.io.git</span><br></pre></td></tr></table></figure><p>更换theme最简单的做法就是git clone theme主题后复制到themes下，然后修改my_blog下的_config.yml中theme属性，这里我用的是indigo</p><p><a href="https://github.com/yscoder/hexo-theme-indigo/wiki" target="_blank" rel="noopener">https://github.com/yscoder/hexo-theme-indigo/wiki</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: hexo-theme-indigo</span><br></pre></td></tr></table></figure><p>indigo中默认是没有开启tags和categories的，找了半天才明白需要按照上面链接的wiki手工设置，具体在issue中也有回答。</p><p><a href="https://github.com/yscoder/hexo-theme-indigo/issues/154" target="_blank" rel="noopener">https://github.com/yscoder/hexo-theme-indigo/issues/154</a></p><p>搭好之后修改下my_blog/_config.yml中一些基本显示信息就OK了。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        今天情人节，也是大年29，趁着这段时间不忙给已经废弃的blog换个theme，简单记录下。&lt;/p&gt;
&lt;p&gt;​        hexo 和 github搭建blog网上很多资料，这里只记录一些问题。下面是一些常见命令：&lt;/p&gt;
&lt;figure class=&quot;
      
    
    </summary>
    
      <category term="Technology" scheme="darktemple9.github.io/categories/Technology/"/>
    
    
      <category term="Hexo" scheme="darktemple9.github.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>直销银行，生存更重要</title>
    <link href="darktemple9.github.io/2017/12/10/%E7%9B%B4%E9%94%80%E9%93%B6%E8%A1%8C%EF%BC%8C%E7%94%9F%E5%AD%98%E6%9B%B4%E9%87%8D%E8%A6%81/"/>
    <id>darktemple9.github.io/2017/12/10/直销银行，生存更重要/</id>
    <published>2017-12-10T09:32:07.000Z</published>
    <updated>2018-02-13T13:41:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>​        最近经常看到直销银行这个词，正好前些日子看新闻说百信银行在北京开业了。关注了一些材料，接触了一些产品，对于直销银行本身有些思考。</p><p>​        直销银行这个概念其实是互联网金融时代的产物，基本就是不设线下实体网点，所有业务都是通过网上银行、ATM、手机银行等远程业务模式与终端客户进行业务往来的银行。目前来看，除了百信银行这种独立法人形式的直销银行外，更多的是中小型银行喜欢建立直销银行，但一般多是该行底下的一个部门。虽然各种领导给百信银行站台，背后大股东中信和百度都是非常有实力的，但本身其前景我认为还是有些挑战的。</p><p>​        第一就是如何生存。从一些银行官网看我感觉直销银行的定位就是“存款+理财+货币基金”，但是银行业本身的信贷业务没影子。这种产物的业务模式目前来看并没有太大的核心竞争力。纵观我看过国内区域银行的一些产品，基本就停留在用更高的投资收益来吸引客户。有文章说直销银行的服务对象是零售客户，可是直销银行有场景吗？和那些大型支付公司比它怎么获取客流呢？支付公司或者传统银行可以获取其签约商户的各种数据，有利于建立商户的信用评级，根据数据流量能更精准的提供服务，从某种意义上这是一种普惠金融。可直销银行呢，没有场景怎么积累数据呢？给小微企业提供金融服务本身就有风险，其客户画像本身不好刻画。搞金融和安全一样，我认为风险控制要永远高于其他，更不用说和一些炒作概念型的创新相比了。</p><p>​        再来说说同质化问题。我发现同质化问题不止安全圈的各种产品同质化严重，银行业本身也不少。就拿百信银行来说，我真的很想知道百信银行和百度金融相比有什么更特别的地方，或者更直白点和那些互联网公司成立的金融集团相比有何竞争力？刚成立几年可能集团股东、有关部门领导会给予大量支持，但是后来呢？直销银行也是企业，还是得创造利润来生存，这部分利润怎么创造呢？靠着大数据、AI智能投顾等各种过度包装的技术就能解决了？很多时候我们讲要将金融服务于实体，要践行普惠金融。这种顶层设计是绝对正确的，可是具体到经营咱们得想商业模式，到底直销银行服务于谁，怎么生存、怎么能在各种互联网金融集团的包围中存活下来是最关键的。</p><p>​       最后我还是想再次强调，FinTech可能本身可以提高我们的效率，节约我们的运营成本。但是初创企业最重要的还是要尽可能的盈利，尽可能得有自己的壁垒和城墙来活下去，否则万一哪天不在风口浪尖了，第一个倒下怕不是这种概念型的产物了。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        最近经常看到直销银行这个词，正好前些日子看新闻说百信银行在北京开业了。关注了一些材料，接触了一些产品，对于直销银行本身有些思考。&lt;/p&gt;
&lt;p&gt;​        直销银行这个概念其实是互联网金融时代的产物，基本就是不设线下实体网点，所有业务都是通过网上银行
      
    
    </summary>
    
      <category term="Compliance" scheme="darktemple9.github.io/categories/Compliance/"/>
    
    
      <category term="Policy" scheme="darktemple9.github.io/tags/Policy/"/>
    
  </entry>
  
  <entry>
    <title>Janus漏洞一些记录</title>
    <link href="darktemple9.github.io/2017/12/10/Janus%E6%BC%8F%E6%B4%9E%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
    <id>darktemple9.github.io/2017/12/10/Janus漏洞一些记录/</id>
    <published>2017-12-10T08:19:54.000Z</published>
    <updated>2018-02-13T13:40:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近这两天经常看到关于Janus漏洞的转载，大致意思是修改App而不影响签名，特记录汇总一些细节。</p><p>参考：</p><p><a href="https://www.guardsquare.com/en/blog/new-android-vulnerability-allows-attackers-modify-apps-without-affecting-their-signatures" target="_blank" rel="noopener">https://www.guardsquare.com/en/blog/new-android-vulnerability-allows-attackers-modify-apps-without-affecting-their-signatures</a> </p><p><a href="https://www.anquanke.com/post/id/89979" target="_blank" rel="noopener">https://www.anquanke.com/post/id/89979</a></p><p><a href="https://source.android.com/security/apksigning/v2?hl=zh-cn#integrity-protected-contents" target="_blank" rel="noopener">https://source.android.com/security/apksigning/v2?hl=zh-cn#integrity-protected-contents</a></p><p>背景介绍：</p><p>Google在Android 7.0后引入了v2作为APK签名方案。这种方案是一种全文件签名方案，为了向下兼容。开发者应该先用JAR签名功能对APK进行签名，然后再使用v2方案进行签名。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws2.sinaimg.cn/large/006tKfTcly1fmbr1gdqnoj316m08k75r.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>上图中APK签名分块就包含v2签名和签名者身份信息。</p><p>APK签名分块负责保护ZIP条目的内容、ZIP中央目录、ZIP中央目录结尾及APK签名方案v2分块中的signed data的数据完整性。</p><p>CVE-2017-13156 Janus漏洞<img src="" alt=""></p><p>APK文件是一个zip文件，它可以在zip文件之前（或者是在zip文件之间）包含任意字节。JAR签名模式（v1）只会考虑zip条目，这个方案在计算或者验证应用签名时会忽略额外字节。另外，Dex文件可以包括在最后包括任意字节，例如在常规的Sections之后strings、classes、method definitions之后。总结成一句话就是一个文件可以同时是apk文件和dex文件！</p><p>另外一个触发关键因素是ART虚拟机。理论上来说，在Android运行时载入APK后会提取DEX文件，然后执行相关代码。但在实际中，ART虚拟机可以载入并执行APK文件和DEX文件。如果找到APK文件，会根据Header中magic特征字节来判断文件类型。如果找到Dex Header，它会载入DEX文件。否则，虚拟机会将包含DEX文件的APK载入。</p><p>攻击者可以利用这种二元性，即将恶意Dex文件放到APK文件中，这样在基于JAR的签名方案下就不会影响签名。Android运行时会将这种APK看做是之前合法APK的一种升级，允许安装，然后从下图中DEX Header开始执行。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws4.sinaimg.cn/large/006tKfTcly1fmbr1fiivoj30wk0q0ta1.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>影响范围：</p><p>目前来看Janus漏洞主要针对的是Android 5.0到Android7.0的版本，利用V2 方案签名的应用不受此影响，主要是因为V2签名方案会考虑APK文件中的所有字节。</p><p>网上有人放出了POC <a href="https://github.com/V-E-O/PoC/tree/master/CVE-2017-13156" target="_blank" rel="noopener">https://github.com/V-E-O/PoC/tree/master/CVE-2017-13156</a></p><p>我参考使用说明跑了遍，</p><p>python janus.py malware.dex original.apk out.apk</p><p>可以安装成功但是运行时会退出。</p><p>后记：目前还是不太明白实际的攻击效果，特别是对于金融级别这种上了apk完整校验保护方案的产品，有没有实质性的破坏力，我实验的2个产品都是能安装但是运行不起来，后序需要跟踪学习下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近这两天经常看到关于Janus漏洞的转载，大致意思是修改App而不影响签名，特记录汇总一些细节。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.guardsquare.com/en/blog/new-android-vulnerabilit
      
    
    </summary>
    
      <category term="Security" scheme="darktemple9.github.io/categories/Security/"/>
    
    
      <category term="Android Security" scheme="darktemple9.github.io/tags/Android-Security/"/>
    
  </entry>
  
  <entry>
    <title>平安真的高估了吗？</title>
    <link href="darktemple9.github.io/2017/12/03/%E5%B9%B3%E5%AE%89%E7%9C%9F%E7%9A%84%E9%AB%98%E4%BC%B0%E4%BA%86%E5%90%97%EF%BC%9F/"/>
    <id>darktemple9.github.io/2017/12/03/平安真的高估了吗？/</id>
    <published>2017-12-03T01:38:37.000Z</published>
    <updated>2018-02-13T13:42:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>​        自从11月初买入中国平安，一度盈利超过15%。但是上周的下跌直接将获利大幅回吐。摩根大通在H股直接高位卖出套现115亿，作为小散的我又将何去何从呢？简单记录下想法。。</p><p>​        简单回顾下当时平安的买入逻辑。国债750线上移，明年准备金大幅减少利好寿险。其次是我认为保险也面临着消费升级，即中国的中产一代越来越重视保险，投保人数会逐年递增。第三就是平安集团的几个潜在业务我非常看好。第一是最近很火的Fintech，但凡有点名气的企业都往这上面靠，金融+科技、电商+科技等等。作为半从业者，我真的不太care什么区块链、人工智能、大数据及云计算能技术，我就关心一个事情，场景落地。讲技术一定要有落地的场景，一定要能真正解决问题、优化流程并节省开销。我非常看好平安集团的应用场景，具体如下。</p><p>​        首先，我觉得应该明确下银行、保险线上开户的几个重要节点。第一就是身份识别，即人行提出的”了解你的用户“。这里我非常看好人脸识别的落地。其次，保险推销咨询需要很多人工客服，这里面可以用潜在的智能客服来解决大部分问题，有效节约成本。第三是金融业的风控。金融业积累的数据往往可以通过分析加强风控能力，而且可以计算个人征信，有利于更好的描绘用户画像。第四是金融科技的输出。金融云、风控信息共享等一系列技术对于很多中小型银行、保险公司来说是很复杂的，这个时候背靠大集团来搞而自己本身专注于业务拓展是不错的选择。平安科技需要利用好集团的资源，进一步提供优质服务。</p><p>​        再来说说最近发现的一个联动板块。即平安好医生。几周前平安集团和清华大学组建健康医学的相关研究院，依托清华的科研实力和平安的数据来打造健康板块我认为是非常好的思路。我认为好医生的应用范围、应用前景要远远高于陆金所。好医生可以帮助更多的患者享受更好的就诊服务，缓解线下压力。其次是线上积累的数据有利于合作医院的研究，有助于推动大健康医学的进步。其潜在社会价值远远大于P2P公司。</p><p>​        说完了利好也要谈谈风险。最近平安高位回撤近15%，抛压很重。主要原因是获利了结，即平安今年已经涨了一倍，这个位置估值可能不便宜。对于保险业这种看内涵价值的板块，其PEV顶峰快2了。很多投资者觉得高估了。作为非专业人士，我其实更关注18年平安集团的成长性。一个是主业保险的发展，特别是新增用户。另外一个就是Fintech这块的输出能力。再美的愿景也需要落地实现，再漂亮的美人也得见人。18年如果平安科技这块能够贡献更多的利润，或者让我们看到更多的增长，那么平安集团从金融集团向科技集团就是成功的。这时候我们评估平安就应该给予更高的估值。利用PE来计算估值可能比看PEV更好。</p><p>​         最后就是周末的一个重磅消息，美国减税法案通过了。从资料分析来看应该是利空国内市场的，美联储主席换人后明年估计又得开始加息，全世界的钱开始回流美国。中国的外汇保卫战八成又要开始了。不知道央行会如何对抗这一利空。另外，美国也公布了另外一个消息，即不承认我国市场经济。贸易战可能又要来了。目前我还不太明白这里对于大金融板块的影响，有待进一步跟进学习。</p><p>​         总之，平安应该短期内还会回撤，享受完了上涨的喜悦要开始忍受下跌的悲剧了。未来一周如果有反弹大概率会减仓，等待企稳再做定夺。具体离场线设置在65元附近。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        自从11月初买入中国平安，一度盈利超过15%。但是上周的下跌直接将获利大幅回吐。摩根大通在H股直接高位卖出套现115亿，作为小散的我又将何去何从呢？简单记录下想法。。&lt;/p&gt;
&lt;p&gt;​        简单回顾下当时平安的买入逻辑。国债750线上移，明年准备
      
    
    </summary>
    
      <category term="Investment" scheme="darktemple9.github.io/categories/Investment/"/>
    
    
      <category term="Stock" scheme="darktemple9.github.io/tags/Stock/"/>
    
  </entry>
  
  <entry>
    <title>再谈免费加固之梆梆加固</title>
    <link href="darktemple9.github.io/2017/11/30/%E5%B0%8F%E8%AE%AE%E6%A2%86%E6%A2%86%E5%8A%A0%E5%9B%BA/"/>
    <id>darktemple9.github.io/2017/11/30/小议梆梆加固/</id>
    <published>2017-11-30T13:59:31.000Z</published>
    <updated>2018-02-13T13:38:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>前几日看了个娜迦libvdog.so的免费加固，今天简单看看梆梆加固。</p><p>先看看壳子Application：这回获取app_name不是在AndroidManifest.xml，写在Helper里面了。自定义Application中还是获取原有Application对象即realApplication然后onCreate()，都差不多。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws2.sinaimg.cn/large/006tKfTcly1fm0h1za44ij31jk13uthw.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws3.sinaimg.cn/large/006tKfTcly1fm0h1ww0spj30wq0gkacr.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>其实如果看过企业版就知道，这个单一版还是一个Dex整体隐藏，在内存中还是可以dump的。（后来发现应该还是有函数抽取的。。）</p><p>这里还是用dexextractor来dump dex出来，但是可能是因为启动慢的原因，第一次安装后启动dump失败了，得第二次再启动才能dump到结果。另外注意下设置虚拟机Sdcard的大小，感觉Sdcard初始化100MB太小了。。</p><p>简单的说结果是两个，小点的dex是梆梆壳子的，大点的本身程序。</p><p>接下来问题来了，之前低版本baksmali用不了了，总是报错：</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws4.sinaimg.cn/large/006tKfTcly1fm0h20rtqej30vw09yjuy.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>找了半天原因感觉可能是baksmali版本太低了，解释不了这个odex，然后赶紧下个最新的baksmali.jar包，这里是V2.2.2.<a href="https://bitbucket.org/JesusFreke/smali/downloads/" target="_blank" rel="noopener">https://bitbucket.org/JesusFreke/smali/downloads/</a></p><p>然后想像之前用java -jar baksmali-2.2.2.jar -o output xxx.odex来执行解析，发现一直报错。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws2.sinaimg.cn/large/006tKfTcly1fm0h20dxqrj30xu0g80zq.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>而是要像下面一样：即 java -jar baksmali-2.2.2.jar deodex -d /system/framework/ -o [out_dir] odex</p><p>具体可以参考：<a href="http://blog.csdn.net/lechengyuyuan/article/details/17146729" target="_blank" rel="noopener">http://blog.csdn.net/lechengyuyuan/article/details/17146729</a></p><p>其实要是想直接看的话可以用Jeb 2直接打开这个ODEX文件，它能够自动把里面的inner dex解析出来。</p><p>梆梆企业版和标准版就不是一个路数了，首先看看这个AndroidManifest.xml，这保护的。。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws2.sinaimg.cn/large/006tKfTcly1fm0h1y5t9xj313i0t0qmv.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></p><p>再来说说对dex的保护。这里梆梆企业版应该是上VMP了，从apk直接得到的classes.dex确实可以转成jar来看看源码，但是一涉及到关键就是下面这个样子，是函数抽取还是啥的，反正就是容易读的放到native里去。估计so库的反调试也不少，总之就是让我等小白没招。。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws3.sinaimg.cn/large/006tKfTcly1fm0h218dxrj30ta0kujtx.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>后记：先后看了娜迦和梆梆的免费版加固，其实就是想说很多免费版和企业版完全不是一个路数。目前来讲学习各家免费版的脱壳还是比较有意义的，因为这类免费加固需求非常大。中小企业拿来可以应付监管，恶意软件套个壳子可以过应用市场的自动检测。那么相反，取证人员如果能够了解其中的秘密必然能更好的审查！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前几日看了个娜迦libvdog.so的免费加固，今天简单看看梆梆加固。&lt;/p&gt;
&lt;p&gt;先看看壳子Application：这回获取app_name不是在AndroidManifest.xml，写在Helper里面了。自定义Application中还是获取原有Applicati
      
    
    </summary>
    
      <category term="Security" scheme="darktemple9.github.io/categories/Security/"/>
    
    
      <category term="Android Security" scheme="darktemple9.github.io/tags/Android-Security/"/>
    
  </entry>
  
  <entry>
    <title>dex整体加密与解密初探</title>
    <link href="darktemple9.github.io/2017/11/27/dex%E6%95%B4%E4%BD%93%E5%8A%A0%E5%AF%86%E4%B8%8E%E8%A7%A3%E5%AF%86%E5%88%9D%E6%8E%A2/"/>
    <id>darktemple9.github.io/2017/11/27/dex整体加密与解密初探/</id>
    <published>2017-11-27T13:56:40.000Z</published>
    <updated>2018-02-13T13:40:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近碰到个有趣的壳子，是libvdog.so的免费版，感觉和之前第一代壳子有点像，特此记录下学习点滴。</p><p>随便找个样本，apktool反编译看看AndroidManifest.xml，可以看到一个application标签。利面有个自定义的VDogApplication，还有个meta-data标签。这里meta-data标签里面的就是原Application的信息，如class_name.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006tKfTcly1flwzz8gzc5j319e09oae9.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>App启动的时候，Application中的attachBaseContext方法先调用，这里可以看看具体vdogApplication是怎么实现。这里面定义了原App的application对象，初始化自定义类加载器，获取源程序中的Application名称，通过反射生成原App的application对象。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws2.sinaimg.cn/large/006tKfTcly1flwzz9mixcj31iu0rewqk.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>加载原始的Application一般在onCreate()函数中，加载原始Application对象，并替换为原始Application的引用。调用baseContext并调用原始application的onCreate方法。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://ws1.sinaimg.cn/large/006tKfTcly1flx0v14463j30xo072dhf.jpg" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>Dex整体加密在内存中找到dex明文就可以拿出来，目前试验过的一代壳有几种方式</p><ul><li>梆梆 + 爱加密 + 娜迦</li><li><ul><li>DexExtractor 脱壳机</li></ul></li><li>drizzleDumper</li><li><ul><li>360 一代，百度早期</li></ul></li><li>手工断在libdvm.so dvmDexFileOpenPartial下再配上一段脚本</li><li><ul><li>基本通杀一代壳，如阿里等</li><li>对于一些变态的反调，这个只能练内功。。。</li></ul></li></ul><p>后记：vdog这个其实弄出来还不算整体dex，里面onCreate()是空的，还得修复。。这个需要继续深入了</p><p>看雪文章：                                       <a href="https://bbs.pediy.com/thread-220070.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-220070.htm</a></p><p>onCreate vs attachBaseContext：<a href="http://www.10tiao.com/html/227/201704/2650239403/1.html" target="_blank" rel="noopener">http://www.10tiao.com/html/227/201704/2650239403/1.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近碰到个有趣的壳子，是libvdog.so的免费版，感觉和之前第一代壳子有点像，特此记录下学习点滴。&lt;/p&gt;
&lt;p&gt;随便找个样本，apktool反编译看看AndroidManifest.xml，可以看到一个application标签。利面有个自定义的VDogApplica
      
    
    </summary>
    
      <category term="Security" scheme="darktemple9.github.io/categories/Security/"/>
    
    
      <category term="Android Security" scheme="darktemple9.github.io/tags/Android-Security/"/>
    
  </entry>
  
  <entry>
    <title>深圳之行</title>
    <link href="darktemple9.github.io/2017/10/08/%E6%B7%B1%E5%9C%B3%E4%B9%8B%E8%A1%8C/"/>
    <id>darktemple9.github.io/2017/10/08/深圳之行/</id>
    <published>2017-10-08T11:13:40.000Z</published>
    <updated>2018-02-14T01:10:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>​        一周的深圳之行快要结束了，感慨颇多，特此记录。</p><p>​        这是我第一次来深圳，出了机场第一感觉就是热。感觉整个人就像丢进热笼里一样。坐上出租车往酒店行进，有两个直观感受。一个是车费贵，一个是城市设计凌乱。南山区高楼林立，但是不像北京一样排列非常整齐，显得非常拥挤。深圳的交通自不必说，早晚高峰堵车，但是感觉深圳的高峰期比北京晚1个小时，很可能和南山这边高新科技园里的企业上班晚有关。</p><p>​        说完了出行在聊聊业务。此行南下最大收获就是去了企业的生产线。平常用的电子设备想不到组装时有这么多工序，从原料、设计、装配、验收到出货等工序非常多，流程标准化显得尤为重要。合格的管理体系才能保证企业产品质量，这需要每个管理者进行摸索。此外，此行最大感受就是大力发展实体经济之重要性。诚然，大数据、云计算、人工智能等风口浪尖的技术在推动社会发展，移动支付、智能投资也大大方便了人们的生活，但请不要忘了下游的制造业。我认为技术和理念只是为了更好的革新一个产业，但真正落地还是需要实体制造。实体制造厂商所带来的经济价值和社会价值是非常扎实的。经济上来说，我认为生产具有科技含量的设备能够直接带动地方产业链的<br>健康发展。原料采购带动下游材料生产需求，加工设备的需求能够为中游厂商提供活力，而核心技术的研发则能够使现在很多先进技术充分释放其能力，而非简单成为风投的概念产品。社会价值来讲，我认为实体制造业能够提供大量工作岗位，为每一位踏踏实实工作的人提供一份不错的生活保障。而且制造业是一个国家工业水平的直接体现。我认为我们更应该注重高新技术与实体制造业的有机结合，多关注一些有核心技术的制造业企业。</p><p>​        此行另外一个收获就是安防市场之大，超出想象。工厂流水线需要监控、原料存储需要监控、涉及核心的岗位、办公场所全需要监控和门禁设备。以前觉得就机场、火车站等公共场所需要这些东西，现在发现这些安防产品用途真是广泛。而且这些安防企业有个特点，它是硬件和软件结合在一起卖。软件提供一个增值服务，估计是营收重点。硬件又和制造业相关，能有效带动虚拟经济和实体经济的发展。而且目前一些龙头公司还为各行各业提供了不同的解决方案，对于国家关键基础设施提供一个保障，市场前景颇大。</p><p>​        最后此行就是见到了一些许久不见的老朋友。昨日到润园四季吃了椰子鸡，和几个同学一些聊聊天，非常开心。下午要回北京了，本想去看看深圳湾无奈下雨。以后有机会再说吧。</p><p>2017-9-30 上午写于南山区 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;​        一周的深圳之行快要结束了，感慨颇多，特此记录。&lt;/p&gt;
&lt;p&gt;​        这是我第一次来深圳，出了机场第一感觉就是热。感觉整个人就像丢进热笼里一样。坐上出租车往酒店行进，有两个直观感受。一个是车费贵，一个是城市设计凌乱。南山区高楼林立，但是不像北京一
      
    
    </summary>
    
      <category term="Life" scheme="darktemple9.github.io/categories/Life/"/>
    
    
      <category term="Travel" scheme="darktemple9.github.io/tags/Travel/"/>
    
  </entry>
  
  <entry>
    <title>“航空板块新思路”</title>
    <link href="darktemple9.github.io/2017/09/17/%E2%80%9C%E8%88%AA%E7%A9%BA%E6%9D%BF%E5%9D%97%E6%96%B0%E6%80%9D%E8%B7%AF%E2%80%9D/"/>
    <id>darktemple9.github.io/2017/09/17/“航空板块新思路”/</id>
    <published>2017-09-17T11:22:28.000Z</published>
    <updated>2018-02-13T13:43:17.000Z</updated>
    
    <content type="html"><![CDATA[<p>本日志仅记录投机中的心路历程，属于自娱自乐的日志。</p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>小时候一直有个蓝天梦，可惜后来各种原因只能作罢。但是这些年一直对大飞机情有独钟，这不投机都选航空板块。这里所谓的航空板块，其实是一个大合集。即从上游的发动机建设、下游的整机制造到和我们顾客生活息息相关的机场和航空公司。本文将从这4个方面来记录下自己的投机心路。</p><h3 id="航空发动机"><a href="#航空发动机" class="headerlink" title="航空发动机"></a>航空发动机</h3><p>航空发动机作为国家工业水平的象征，其实是多学科交叉的产物，简单的说涉及动力系统、控制系统、材料等等。国际上真正独立造发动机的公司非常少，基本就是美国、英国垄断，俄罗斯那民用发动机都不太行。16年我们国家成立了中国航发，正式将航空发动机从中航工业剥离出来，独立发展。作为十三五规划的头等大事，其地位可想而知。日前，证监会仅用40余天通过百亿定增，可见国家对于航空发动机建设的支持。从政策面来说，中国航发没有理由搞不好航空发动机，没有理由辜负国家、人民对于航空发动机的期许。从基本面来说，航发集团成立这一年确实干了不少事，这里有两件我最看重。第一是削减非航空主营业务，集中力量发展发动机。这条非常重要，一个企业如果不能专注于其核心产业，能指望它干出什么业绩？第二就是对于人才的培养，和北航、西航等名校联合培养人才，让更多的青年才俊投身到祖国的航空发动机建设当中。发动机这个学科最大的特点就是需要大量的实验，说句外行话就是产物是在大量实验失败基础上产生的。高校和企业结合可以有效的做到理论到实践的过渡，为日后创新打下基础。航发三剑客之首的航发动力已经处于价值洼地。目前总市值才不到620亿，具备一定的投资机会。今年黎明厂的业绩提升直接带动公司盈利水平。太行发动机、峨眉发动机等都是航发集团的龙头产品，是国家给予高度期望的中国之心。歼20换中国心靠的就是ws15，未来5年歼20肯定会成批列装空军，发动机的产业价值还是值得期待的。扯了半天美好愿景，最后说说持股心态吧。以前军工基本是事件驱动因素的，地缘风险基本能拉升股价，各种重组预期炒作导致军工股非常贵。今年来看，A股的玩法往业绩靠拢，这个时候持有军工就不能再有赌地缘风险的心态（当然朝鲜这个一直射导弹也有点影响）。我认为最关键的是向好的业绩支撑。航发动力目前走势有点慢牛的意味，其估值会慢慢修复，适合长线持有。</p><h3 id="大飞机制造"><a href="#大飞机制造" class="headerlink" title="大飞机制造"></a>大飞机制造</h3><p>如果说发动机产业算是上游产业，那么整机制造算是下游了吧。中航飞机作为运20、C919的主要生产商是制造大飞机厂商中当仁不让的龙头。大型运输机在民用上最大的用处就是救援，在军用上可以是投放装备，也可以改改往加油机发展。我国目前来说需求量非常大。相对于运20，C919大飞机可能要慢些。我估计要想成熟使用还得需要5-10年。目前来说搏击C929年底的飞行可能算是预期。作为中线标的，不会持有太久。</p><h3 id="机场"><a href="#机场" class="headerlink" title="机场"></a>机场</h3><p>航空公司和机场一起说。这两个都是所谓的C端，即和我们这些顾客真正相关的。相对于航空公司，我个人更偏爱机场投资。A股3大机场，上海、白云和深圳。上海机场是当仁不让的龙头，但是估值溢价有点多，不符合我投机的理念。我比较看好白云机场。18年T2开通使用、22年白云机场三期改造完工这些利好消息我不多赘述。我就提3个关注点。第一，白云机场作为珠三角的核心机场，未来无论是地理位置还是扶持力度肯定超过香港机场，配合一带一路映射东南亚效应肯定进一步扩散。第二个就是航站楼的建设，广告和免税店必将带动业绩。免税店可以方便顾客买奢侈品，也可以防止更多外汇留到外国。广告响应可以参考首都T3国航展出的工行广告。第三个就是管理，也是白云机场为啥市值不到280亿的原因。白云机场的管理相对于香港、上海机场有些差距，如果T2投入使用能够提高管理，必将突破。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>三大公司我都没有谈PE、PB这些玩意，主要是我不懂，次要是我觉得估值这玩意每个人有自己的见解，我觉得目前价位合适就分批买入，本金小好调头。至于所谓的各种短线理论，我不会也不想学。我投资的是国家航空的未来，我看好的是航空板块的发展。</p><p>目前持有航发动力、中航飞机，白云机场观望中！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本日志仅记录投机中的心路历程，属于自娱自乐的日志。&lt;/p&gt;
&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;小时候一直有个蓝天梦，可惜后来各种原因只能作罢。但是这些年一直对大飞机情有
      
    
    </summary>
    
      <category term="Investment" scheme="darktemple9.github.io/categories/Investment/"/>
    
    
      <category term="Stock" scheme="darktemple9.github.io/tags/Stock/"/>
    
  </entry>
  
</feed>
